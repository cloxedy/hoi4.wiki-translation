<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Модинг Подій HOI4</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto:wght@700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="./styles/styles.css"> 
</head>
<body class="theme-light theme-dark-base"> 
<div class="page-wrapper">
    <div class="top-bar">
        <div class="controls">
            <label for="language-switcher">Мова:</label>
            <select id="language-switcher" onchange="switchLanguage(this.value)">
                <option value="uk" selected>Українська</option>
                <option value="ru">Русский (events_ru.html)</option> 
            </select>

            <label for="theme-switcher">Тема:</label>
            <select id="theme-switcher">
                <option value="theme-light">Світла</option>
                <option value="theme-aistudio-dark">AI Studio Dark</option>
                <option value="theme-nord-dark">Nord Dark</option>
                <option value="theme-dracula">Dracula</option>
                <option value="theme-one-dark-pro">One Dark Pro</option>
            </select>
        </div>
        <div class="quick-nav-link">
            <a href="./index" class="nav-button">← Головна сторінка</a> 
            <a href="#header-text" class="nav-button">Вгору &#x2191;</a>
            <a href="#focused-navigation-menu" class="nav-button">Меню розділів &#x2193;</a>
        </div>
    </div>

    <header>
        <h1 id="header-text">Модинг подій (Events)</h1>
    </header>

    <div class="container">
        <div class="disclaimer">
            <p><strong>Увага!</strong> Це переклад оригінальної сторінки <a href="https://hoi4.paradoxwikis.com/Event_modding" target="_blank" rel="noopener noreferrer">Event modding - Hearts of Iron 4 Wiki</a>.</p>
            <p>Я не є автором оригінального контенту. Переклад виконано за допомогою інструментів штучного інтелекту та може містити неточності. Оригінал знаходиться за вказаним посиланням.</p>
        </div>

        <div id="main-content">
            <p><em>Це вікі, що підтримується спільнотою. Якщо ви помітили помилку, будь ласка, допоможіть її виправити.</em></p>

            <p>Події визначаються в папці <code>/Hearts of Iron IV/events/</code>. Існує кілька типів подій, що змінюють вигляд або ціль подій.</p>
            <p>Список типів подій включає <code>country_event</code>, <code>news_event</code>, <code>state_event</code>, <code>unit_leader_event</code> та <code>operative_leader_event</code>.</p>
            <p>У кожному типі подій область видимості <code>ROOT</code> посилається на країну, яка отримує подію, однак стандартна передбачувана область видимості, також відома як <code>THIS</code>, не завжди є суто країною. У подіях штату, подіях лідера оперативників та подіях лідера підрозділу передбачувана область видимості охоплює як країну, так і специфічний для події тип області видимості, приймаючи ефекти для будь-якої з областей видимості, сортуючи їх за бажанням. У випадку збігу між тим, що можливо для країни або іншої області видимості (наприклад, <code>add_manpower</code> є ефектом як для штату, так і для країни), перевага надається країні.</p>
            <p>Через цю плутанину рекомендується уникати подій штату, оскільки вони виглядають ідентично подіям країни (замість них можна використовувати цілі подій у подіях країни, спрямованих на конкретний штат), однак події лідера підрозділу та лідера оперативників можуть бути неминучими через їхній відмінний вигляд. Між типами подій майже немає різниці, за винятком вигляду, стандартних областей видимості та того факту, що для новинних подій можна вимкнути спливаюче вікно (однак країна все одно їх отримає). Якщо країна гравця отримує подію і не обирає варіант, за замовчуванням буде обрано перший варіант.</p>
            <p>При спрацьовуванні за допомогою ефекту гра переносить звичайні цілі подій, що існують у попередньому блоці ефектів, до події, а також область видимості <code>ROOT</code> блоку, яка стає <code>FROM</code> всередині події. Області видимості <code>FROM</code> попереднього блоку ефектів зміщуються на один рівень вниз, причому <code>FROM</code> блоку ефектів стає <code>FROM.FROM</code>, попередній <code>FROM.FROM</code> стає <code>FROM.FROM.FROM</code> і так далі. Через це <code>FROM</code> у жаргоні часто називають "відправником" події, роблячи <code>FROM.FROM</code> відправником відправника. Хоча це не завжди так, оскільки <code>FROM.FROM</code> може бути чимось зовсім іншим, наприклад, додатковою областю видимості всередині <code>on_actions</code> або ціллю рішення. Важливо, що це те, чим є блок <code>FROM</code> ефекту, який її запустив, що залежить від того, де саме вона була запущена.</p>
            <p>Цього не відбувається, якщо подія запускається за допомогою блоку <code>random_events</code> в <code>on_action</code>: застосовуються ті ж правила областей видимості, що й у звичайному <code>on_action</code>.</p>
            <p>Країна, яка не існує, все ще може отримувати події, якщо вони запущені через ефект, але будь-який інший метод не працює. Однак, якщо в ефекті, що запускає подію, встановлена затримка часу, таймери в кожному <code>delayed_event</code><sup>[a]</sup> не зменшуватимуться. Це фактично ставить будь-які події із затримкою часу в чергу очікування для країни, призупиняючи їх доти, доки країна не буде звільнена. Наприклад, якщо BHR не існує, коли виконується <code>BHR = { country_event = { id = event.0 days = 1 } }</code>, то подія спрацює лише через день після того, як BHR почне існувати. Це також стосується початкового одержувача великих подій.</p>

            <div class="table-of-contents">
                <h3>Зміст</h3>
                <ul>
                    <li><a href="#event-creation">1. Створення події</a>
                        <ul>
                            <li><a href="#id-rules">1.1. Правила ID</a></li>
                            <li><a href="#localisation-event">1.2. Локалізація</a></li>
                            <li><a href="#picture-event">1.3. Зображення</a></li>
                            <li><a href="#triggering-event">1.4. Запуск</a></li>
                            <li><a href="#options-event">1.5. Опції</a></li>
                            <li><a href="#additional-arguments-event">1.6. Додаткові аргументи</a></li>
                        </ul>
                    </li>
                    <li><a href="#effect-event">2. Ефект</a></li>
                    <li><a href="#common-mistakes-event">3. Поширені помилки</a>
                        <ul>
                            <li><a href="#unlogged-errors-event">3.1. Незареєстровані помилки</a></li>
                            <li><a href="#unintuitive-logged-errors-event">3.2. Неінтуїтивні зареєстровані помилки</a></li>
                        </ul>
                    </li>
                    <li><a href="#event-file-example">4. Приклад файлу події</a>
                        <ul>
                            <li><a href="#integration-on-actions-event">4.1. Інтеграція з on_actions</a></li>
                            <li><a href="#integration-history-event">4.2. Інтеграція з історією</a></li>
                        </ul>
                    </li>
                    <li><a href="#notes-references-event">5. Примітки та посилання</a></li>
                </ul>
            </div>
            
            <h2 id="event-creation">1. Створення події</h2>
            <p>Кожна подія міститься в блоці коду, що відповідає типу події, наприклад, <code>country_event</code> або <code>news_event</code>. Усередині події обов'язковим є рядок <code>id</code>, що відповідає ID події, наприклад, <code>id = my_event.123</code>.</p>

            <h3 id="id-rules">1.1. Правила ID</h3>
            <p>У файлі подій усі події повинні мати ID у форматі <code><простір_імен>.<цілочисельний_ID></code>. Наприклад, у події <code>my_event.123</code>, простір імен буде "my_event", а ID — "123".</p>
            <p>Простір імен повинен бути створений перед визначенням будь-яких подій, які його використовують. Це робиться рядком <code>add_namespace = my_event</code>, який повинен знаходитися поза будь-якою подією. Якщо простір імен не визначено, ID події буде вважатися неправильно сформованим токеном, що призведе до того, що вона не працюватиме в грі. Простір імен події складається з символів слова (наприклад, літери англійського алфавіту або підкреслення). Це включає крапки: <code>add_namespace = my_event.subtopic</code> можна використовувати для подій типу <code>id = my_event.subtopic.1</code>. Числовий ID буде взято як все, що йде після останньої крапки, перетворене на ціле число, або 0, якщо перетворення не вдалося.</p>
            <p>Внутрішні ID визначаються для подій шляхом присвоєння ID кожному простору імен (ID присвоюються в порядку в коді, файли завантажуються за назвою файлу в порядку символів), причому першому визначеному простору імен присвоюється ID 10, збільшуючи його на 1 для кожного наступного створеного простору імен, множачи його на 100000 і додаючи цілочисельний ID. Якщо ID після простору імен не вдається перетворити на ціле число, він за замовчуванням стане 0. З цієї причини кожна подія з нецілочисельним ID вважатиметься тією ж самою подією, тому ID події після простору імен повинен бути цілим числом.</p>

            <h3 id="localisation-event">1.2. Локалізація</h3>
            <p>Рядки <code>title</code> та <code>desc</code> використовуються для присвоєння ключа локалізації події, створюючи її заголовок та опис залежно від поточної мови гри. Приклад рядка: <code>title = my_event.123.t</code> або <code>desc = my_event_description</code>. Подія повинна мати заголовок або опис, якщо вона не прихована.</p>
            <p>Локалізація визначається в папці <code>/Hearts of Iron IV/localisation/english/</code> для англійської мови. Бажано використовувати новий файл у папці замість перезапису будь-яких файлів базової гри. Новостворений файл повинен закінчуватися на <code>_l_english.yml</code> у своїй назві (зауважте, що це мала літера L, а не велика I), щоб він правильно завантажувався. Крім того, він повинен використовувати кодування тексту UTF-8-BOM. Точні деталі щодо зміни кодування залежать від використовуваного текстового редактора. Усередині файлу, припускаючи, що <code>l_english:</code> вже додано як перший рядок, локалізацію можна додати так:</p>
            <pre><code> my_event.123.t: "Мій заголовок події"
 my_event_description: "Мій опис події"</code></pre>
            <p>Також можливо додати кілька заголовків та описів до події, змушуючи її обирати один залежно від умов. Це робиться наступним чином:</p>
            <pre><code>title = {
    text = my_event.123.t.a
    trigger = {
        tag = ENG
    }
}
title = {
    text = my_event.123.t.b
}</code></pre>
            <p>Гра обере перший ключ локалізації, де умови виконані. У цьому випадку заголовок події використовуватиме ключ локалізації <code>my_event.123.t.a</code>, якщо країна, що отримує подію, має тег ENG, а всі інші країни матимуть заголовок події, що використовує ключ локалізації <code>my_event.123.t.b</code>. <code>trigger</code> — це блок тригерів, що вимагає, щоб усі тригери всередині були істинними за замовчуванням. Форматування для описів подій таке ж саме, тільки <code>title</code> замінено на <code>desc</code>.</p>

            <h3 id="picture-event">1.3. Зображення</h3>
            <p>Щоб додати зображення, яке буде показано для події, використовується аргумент <code>picture</code> з назвою спрайта, що веде до файлу зображення, наприклад, <code>picture = GFX_my_sprite</code>.</p>
            <p>Спрайти визначаються в будь-якому файлі <code>/Hearts of Iron IV/interface/*.gfx</code>, за замовчуванням використовуючи <code>eventpictures.gfx</code>, який відкривається будь-яким текстовим редактором. Рекомендується створити новий файл у папці замість використання файлу базової гри в моді з міркувань сумісності з оновленнями. У вибраному вами файлі <code>/Hearts of Iron IV/interface/*.gfx</code> можна додати наступні рядки всередині блоку <code>spriteTypes = { ... }</code> для визначення спрайта:</p>
            <pre><code>spriteType = {
    name = "GFX_my_sprite"
    texturefile = "gfx/event_pictures/my_event_picture.dds"
}</code></pre>
            <p>Після створення цього спрайта файл <code><yourmod>/gfx/event_pictures/my_event_picture.dds</code> можна використовувати в події як <code>picture = GFX_my_sprite</code>.</p>

            <h3 id="triggering-event">1.4. Запуск</h3>
            <p>Блок тригерів <code>trigger = { ... }</code> використовується для оголошення умов, які повинні бути виконані, щоб подія могла з'явитися. Якщо він хибний, немає способу запустити подію, крім використання консольної команди. Це виглядатиме так:</p>
            <pre><code>trigger = {
    tag = GER
    has_political_power > 100
}</code></pre>
            <p>Якщо подія запускається в консолі, тригер буде записаний у неї як вміст звичайної підказки тригера, виділяючи, які умови були виконані, а які ні.</p>
            <p>За замовчуванням подія спрацьовує автоматично. Це полягає в тому, що тригер перевіряється кожні 20 днів.<sup>[1]</sup> Якщо він істинний, перевірка змінюється на щоденну перевірку <code>mean_time_to_happen = { ... }</code>. Це модифікований блок MTTH: він оцінюється для країни та повертає кількість днів; якщо повернута кількість днів дорівнює M, шанс спрацювання події в цей день становить 1 - 2<sup>-(1/M)</sup>, що робить це медіанним часом до настання. Якщо тригер хибний при щоденній перевірці, він повертається до перевірки тригера кожні 20 днів.</p>
            <p><code>mean_time_to_happen = { ... }</code> має атрибути <code>days</code>, <code>months</code> та <code>years</code> для визначення базової кількості днів. Місяць інтерпретується як 30 днів, рік — як 365 днів. Якщо кількість днів повинна бути динамічною, <code>modifier = { ... }</code> служить блоком тригерів з додатковими атрибутами <code>add = 123</code> (додає цю кількість днів) та <code>factor = 0.2</code> (множить кількість днів на вказане число). Модифікатори оцінюються в порядку їх розміщення, і вони підтримують змінні в аргументі. Приклад середнього часу до настання виглядає так:</p>
            <pre><code>mean_time_to_happen = {
    days = 10
    years = 1  # 375 днів як база.
    modifier = {
        factor = 0.2        #  Для POL спрацьовує на 20% швидше, або за 75 днів.
        tag = POL
    }
}</code></pre>
            <p>Автоматичний запуск можна вимкнути, додавши <code>is_triggered_only = yes</code> до події. Це не запобігає будь-якому іншому способу запуску події, чи то через ефект, що використовується для цього, чи через <code>random_events</code> в <code>on_action</code>, чи через прикордонну війну, чи будь-що інше. Це абсолютно не пов'язано з <code>trigger = { ... }</code>: умови всередині все ще повинні бути виконані, щоб будь-який з цих способів міг запустити подію. Якщо ефект, що використовується для запуску події (наприклад, <code>country_event</code> або <code>state_event</code>), встановлений із затримкою, то тригер повинен бути істинним, коли подія має бути запущена.</p>
            <p><code>fire_only_once = yes</code> робить неможливим запуск події більше одного разу. Це перевіряється всередині самої події: країна, що отримує подію, також запобігатиме отриманню її будь-якою іншою країною. Це обходиться за допомогою консольної команди.</p>
            <p><code>major = yes</code> використовується для того, щоб подія спрацювала для кожної країни, як тільки будь-яка країна її отримає. Це робиться в кожній новинній події, оскільки новинні події є суто графічним переоформленням подій країни. У випадку збігу з <code>fire_only_once = yes</code>, останній матиме пріоритет і усуне будь-який ефект того, що подія є великою, змушуючи її з'являтися лише для країни, яка отримує її вперше. Країни, крім першої країни, що отримує її, ігноруватимуть <code>trigger = { ... }</code>. Щоб лише деякі країни отримували показану подію, поки вона все ще велика, використовується <code>show_major = { ... }</code> як блок тригерів, який змушує подію з'являтися лише якщо він істинний. Якщо також додано <code>fire_for_sender = no</code>, подія спрацює для кожної країни, яка відповідає <code>show_major</code>, крім країни, яка мала її отримати.</p>

            <h3 id="options-event">1.5. Опції</h3>
            <p>Опція події додається за допомогою блоку <code>option = { ... }</code>. Опція події — це блок ефектів з кількома додатковими опціями:</p>
            <ul>
                <li><code>name</code> визначає ключ локалізації, що використовується для опції, наприклад, <code>name = my_option_name</code>. Неможливо зробити так, щоб назва опції залежала від тригерів так само, як це можливо для заголовків подій; замість цього можна використовувати абсолютно різні опції подій, вимикаючи кожну з назвою, яка не повинна використовуватися.</li>
                <li><code>trigger = { ... }</code> — це блок тригерів, що визначає, коли опція видима для вибору. Якщо тригер хибний під час запуску, він не з'явиться, доки подія не буде запущена знову. Крім того, для великих подій можна використовувати <code>original_recipient_only = yes</code>, щоб забезпечити, що лише країна, яка запустила подію, має цю опцію доступною, а інші — ні.</li>
                <li><code>ai_chance = { ... }</code> — це блок, що визначає шанс ШІ для опцій подій: пропорційно вирішуючи, яку опцію обрати. Шанси ШІ в опціях подій не обов'язково повинні сумуватися до 100, оскільки вони пропорційні. Він структурований майже ідентично середньому часу до настання. Якщо не встановлено, вважається 1. Ймовірність кожної опції — це її вага, поділена на суму всіх ваг опцій. Якщо всі опції мають вагу нуль, обирається перша. Випадковий вибір здійснюється кидком d100, тому опції не можуть мати ефективну ненульову ймовірність нижче 1%. Вибір залишається послідовним при перезавантаженнях, базуючись на унікальному зерні гри, внутрішньоігровому часі, країні та лідері підрозділу.</li>
            </ul>
            <p>Як блок MTTH, атрибути мають форму <code>base = 10</code>, <code>factor = 0.1</code>, <code>add = 10</code>, з <code>modifier = { ... }</code>, що служать блоками тригерів:</p>
            <pre><code>ai_chance = {
    base = 10.5

    # Якщо країна - Німеччина, встановити значення 0,
    # що призведе до дострокового завершення оцінки.
    modifier = { tag = GER factor = 0 }
    modifier = { is_major = yes add = 1 }
    modifier = {
        factor = 3
        add = 2.5
        tag = FRA
    }
    factor = 2
}</code></pre>

            <h3 id="additional-arguments-event">1.6. Додаткові аргументи</h3>
            <ul>
                <li><code>immediate = { ... }</code> — це блок ефектів, що виконується, як тільки подія запускається, перш ніж гравець обере опцію. Це також можна використовувати для ШІ: ШІ обирає опцію лише після того, як тригери події оцінені для кожної іншої країни, тоді як <code>immediate</code> виконується негайно, перш ніж оцінювати інші події. Це можна використовувати у великих подіях типу "середній час до настання": зробивши так, щоб <code>immediate</code> встановлював глобальний прапор, який повинен бути не встановлений у тригері події, це запобігатиме її запуску більше одного разу для кожної країни, але бажано взагалі уникати подій типу "середній час до настання". Зауважте, що ефект з'явиться в підказці після опису події, тому інструмент потоку <code>hidden_effect</code> може бути корисним.</li>
                <li><code>timeout_days = 20</code> встановлює кількість днів, протягом яких гравець повинен обрати опцію, перш ніж перша опція буде автоматично обрана. Це можна використовувати, щоб зробити подію більш-менш терміновою, ніж за замовчуванням. Якщо не встановлено, вважається 13 днів.<sup>[2]</sup></li>
                <li><code>hidden = yes</code> зробить подію прихованою. Прихована подія не потребує заголовка чи опису. Перша визначена опція, якщо така є, буде автоматично обрана при запуску. Приховані події можуть бути корисними замість скриптованих ефектів для затримки виконання блоку ефектів на певний період часу або для використання області видимості <code>FROM</code>.</li>
                <li><code>minor_flavor = yes</code> позначає подію як незначну подію для атмосфери. Це не змінює її вигляд або ефекти, але дозволяє вимкнути спливаюче вікно в меню рішень гри.</li>
            </ul>

            <hr>
            <h2 id="effect-event">2. Ефект</h2>
            <p>Будь-який блок ефектів може бути використаний для запуску події, наприклад, нагороди за фокуси, опції подій або ефекти рішень. Це зазвичай поєднується з <code>is_triggered_only = yes</code> всередині події, щоб вимкнути автоматичний запуск.</p>
            <p>У найпростішому вигляді це робиться за допомогою ефекту <code>country_event = my_event.1</code> (або <code>news_event = my_event.1</code>), який миттєво запустить подію для країни в області видимості. Оскільки події країни та новинні події по суті є одним і тим же, обидва скорочені ефекти можна використовувати як для подій країни, так і для новинних подій, без жодної різниці між ними. Однак можна додати більше опцій, головним чином для налаштування затримки. Крім того, розширені версії є обов'язковими для подій штату та лідера оперативників.</p>
            <p>Більш складний ефект для запуску: <code>country_event = { id = my_event.1 days = 100 random_days = 123 }</code>. Це запустить подію через 100-223 (100 + 123) дні. Існують наступні аргументи, які можуть увійти в ефект (усі вони опціональні, за одним винятком):</p>
            <ul>
                <li><code>id = my_event.1</code> — ID події для запуску. Це обов'язково, щоб гра знала, яку подію запускати.</li>
                <li><code>hours = 1|days = 2|months = 3</code> — Нижня межа необхідного часу, через який спрацює подія. У цьому випадку місяць розглядається як рівно 30 днів. Якщо використовується кілька з них, гра їх сумує (наприклад, приклад з 1 годиною, 2 днями та 3 місяцями спрацює через 92 дні та 1 годину).</li>
                <li><code>random_hours = 1|random_days = 2</code> — Це встановлює верхню межу необхідного часу, через який спрацює подія. Гра вибирає випадкову кількість (рівномірний розподіл) днів та годин між 0 та встановленою кількістю, включаючи обидва кінці, і додає їх до затримки для запуску події. Аналогічно до вищесказаного, якщо вказано обидва, гра їх сумує. <code>random = 123</code> також служить еквівалентом <code>random_hours = 123</code>.</li>
                <li><code>tooltip = my_event.1.t</code> — Це визначає, як буде відображатися назва події, що спрацює, у локалізації. За замовчуванням назва події, це може бути корисно, якщо заголовок може змінитися між ефектом для її запуску та її фактичною появою.</li>
            </ul>
            <p>Приклад ефекту з використанням кількох з цих параметрів:</p>
            <pre><code>country_event = {
    id = my_event.1
    hours = 12
    random_hours = 6
    days = 2
    tooltip = another_event.1.t
}</code></pre>
            <p>Опціональна затримка неймовірно корисна, оскільки приховані події можна використовувати для створення затримки між виконанням блоку ефектів та фактичним застосуванням ефектів без того, щоб гравець щось помітив. Це також можна використовувати, щоб події виглядали більш "природно": новинні події можуть мати затримку в кілька годин (зазвичай близько 6-12), щоб симулювати час, необхідний інформаційним агентствам для повідомлення про подію. Аналогічно можна зробити з іншими типами подій, щоб симулювати очікування кілька годин на дипломатичну відповідь, замість того, щоб вона була неприродно миттєвою. <code>trigger = { ... }</code> події перевіряється, коли вона мала б спрацювати, що означає, що також можливо запустити подію при запуску гри з необхідною затримкою, щоб отримати її в конкретний день, а потім використати тригер події для симуляції додаткових вимог.</p>
            <p>Крім того, існують такі специфічні для типу події аргументи:</p>
            <ul>
                <li><code>trigger_for = TAG</code> (Унікально для подій штату) — Країна, для якої спрацює подія. Це обов'язково, оскільки події штату повинні запускатися в області видимості штату. Це також можна замінити на <code>controller</code>, <code>owner</code>, <code>occupied</code> або подвійну область видимості, яку можна використовувати як ціль, наприклад, <code>ROOT</code> або <code>FROM</code>.</li>
                <li><code>originator = TAG</code> (Унікально для подій лідера оперативників) — Країна, яка служить ініціатором події (тобто <code>FROM</code>). За замовчуванням власник оперативника, якщо не встановлено.</li>
                <li><code>recipient = TAG</code> (Унікально для подій лідера оперативників) — Країна, яка отримає подію. За замовчуванням власник оперативника, якщо не встановлено.</li>
                <li><code>set_root = TAG</code> (Унікально для подій лідера оперативників) — Змінює область видимості <code>ROOT</code> у динамічній локалізації події, фактично не змінюючи її в коді.</li>
                <li><code>set_from = TAG</code> (Унікально для подій лідера оперативників) — Змінює область видимості <code>FROM</code> у динамічній локалізації події, фактично не змінюючи її в коді.</li>
                <li><code>set_from_from = TAG</code> (Унікально для подій лідера оперативників) — Змінює область видимості <code>FROM.FROM</code> у динамічній локалізації події, фактично не змінюючи її в коді.</li>
            </ul>

            <hr>
            <h2 id="common-mistakes-event">3. Поширені помилки</h2>
            <p>Деякі помилки досить поширені при початку створення подій, чи то через погану практику, чи то вони повністю перешкоджають роботі події. Деякі з них важко помітити під час Модингу, коли подія, здавалося б, працює нормально, наприклад, помилка, яка перешкоджає запуску новинних подій для більш ніж однієї країни. Тут розглянуто деякі з них, а також менш інтуїтивні помилки в лозі.</p>

            <h3 id="unlogged-errors-event">3.1. Незареєстровані помилки</h3>
            <ul>
                <li><strong>Залишення події як "тільки за тригером", коли вона має запускатися автоматично (подія ніколи не спрацьовує)</strong> – <code>is_triggered_only = yes</code> вимикає автоматичний запуск події, натомість змушуючи використовувати для цього ефект. Тому, якщо це залишено в події, призначеній для автоматичного запуску, подія ніколи цього не зробить.<br>
                Зауважте, що <code>trigger = { ... }</code> все ще може співіснувати з <code>is_triggered_only = yes</code>, тому подія з обома <code>is_triggered_only = yes</code> та <code>trigger = { ... }</code> все ще може бути правильною. Допустимі випадки їх одночасного використання включають запуск події через <code>random_events</code> в <code>on_action</code> або затримку в ефекті, що її запускає (де тригер перевірятиме, коли подія має бути отримана), серед інших.</li>
                <li><strong>Невказання країни в тригері для специфічних для країни автоматично запускаються подій (подія спрацьовує для неправильної країни/ніколи не спрацьовує)</strong> – Події жодним чином не прив'язані до країн (простори імен та назви файлів служать суто організаційній меті), і тригер кожної події перевіряється для кожної країни в порядку, вказаному в списку тегів.<br>
                У наведеному прикладі подія вимагає, щоб ITA мала більше 123 політичної влади, після чого країна, що отримує подію, анексує AUS. Однак, як тільки ITA матиме стільки, цей тригер буде істинним незалежно від того, де він перевіряється. Першою країною в списку тегів за замовчуванням є GER, і тому вона буде першою країною, де перевірятимуться тригери. На практиці ця подія призведе до того, що GER анексує AUS, а не ITA.<br>
                У виправленні зроблено зміну: спочатку перевіряється, що країна, яка отримає подію, — це ITA, і лише потім перевіряється, що вона має достатньо політичної влади. Це гарантує, що жодна інша країна не зможе отримати цю подію. Вказувати тег необов'язково, якщо сам тригер вже передбачає певний тег (наприклад, <code>has_completed_focus</code> з фокусним деревом, специфічним для тегу), але в іншому випадку це необхідно.</li>
                <li><strong>Невиправдане використання автоматично запускаються подій замість тих, що запускаються лише за тригером (погана практика/оптимізація)</strong> – Це більше погана практика, ніж помилка. Загалом, якщо умову події можна запустити ефектом, це слід зробити.<br>
                Приклад — найочевидніший спосіб зробити це: перевірка <code>has_completed_focus</code> замість прямого запуску в фокусі. Однак можуть виникати й інші такі випадки, наприклад, коли починається війна між двома країнами, коли штат окуповано, або для запуску події в певну дату. Найкращою практикою є перевірка <code>on_actions</code> перед створенням автоматично запускається події, щоб побачити, чи можна їх відтворити. Запуск через ефект має перевагу миттєвості замість очікування до 20 днів. За бажанням можна додати затримку в кілька годин, щоб це виглядало природніше для гравця. Крім того, це служить способом оптимізації модифікації, оскільки зменшує кількість повторних перевірок тригерів. Події з великим середнім часом до настання особливо погані для продуктивності і в деяких випадках можуть бути замінені блоком ефектів, що запускає подію з великою затримкою, створеною за допомогою <code>random_days</code> всередині ефекту.</li>
                <li><strong>Вузькі межі для тригерів дати (подія ніколи не спрацьовує)/Автоматично запускається подія, призначена для запуску в певну дату (подія спрацьовує пізніше, ніж передбачалося)</strong> – Блок <code>trigger = { ... }</code> перевіряється кожні 20 днів за замовчуванням, і це неможливо змінити лише для однієї конкретної події. Якщо тригери дати встановлені з вузькими верхньою та нижньою межами (наприклад, <code>date > 1936.1.1</code> та <code>date < 1936.1.3</code>), дуже ймовірно, що подія ніколи не спрацює, оскільки це не змусить гру перевіряти тригер у цю дату, а просто не дозволить їй запустити подію, якщо діапазон ніколи не перевіряється, оскільки гра не бачить у майбутнє і не може передбачити, що тригер буде істинним чи хибним у якийсь момент. Аналогічно, просто розміщення <code>date > 1936.1.1</code> не гарантує, що подія спрацює рівно другого січня, але це може бути будь-який день між 2-м та 21-м (хоча це буде той самий день при кожному скиданні).<br>
                Щоб запустити подію в певну дату, найкраще запустити її при запуску гри з необхідною затримкою, встановивши подію так, щоб вона ніколи не спрацьовувала сама по собі за допомогою <code>is_triggered_only = yes</code>, і опціонально додавши додаткові передумови для її появи всередині <code>trigger = { ... }</code>, які будуть перевірені в момент, коли подія має з'явитися. Щоб розрахунок кількості днів був правильним, високосні дні слід ігнорувати, оскільки гра їх не містить.<br>
                Можна використовувати будь-який блок ефектів, виконаний до або під час запуску. Приклад використання <code>on_startup</code> в <code>on_action</code> наведено далі в статті.</li>
                <li><strong>Встановлення новинної події на одноразовий запуск або невстановлення її як великої (новинна подія спрацьовує лише для однієї країни)</strong> – Подія вимагає <code>major = yes</code>, щоб з'явитися для кожної країни. Новинні події є суто переоформленням подій країни і за замовчуванням не налаштовані на запуск для кожної країни, тому цей рядок є обов'язковим. Крім того, події, які спрацьовують лише один раз, не з'являються більше одного разу глобально, а не для кожної країни. Поява події для більш ніж однієї країни вважається її повторним запуском, тому встановлення події на одноразовий запуск призведе до того, що лише одна країна отримає новинну подію замість кожної, як передбачалося.</li>
            </ul>

            <h3 id="unintuitive-logged-errors-event">3.2. Неінтуїтивні зареєстровані помилки</h3>
            <ul>
                <li><code>Event is triggered only, but does not have a 1 base-factor.</code> – Це трапляється, коли в події є суперечливі аргументи щодо того, чи дозволено їй запускатися автоматично, чи її можна запустити лише вручну. Зокрема, <code>mean_time_to_happen = { ... }</code> має ефект лише тоді, коли подію можна запустити лише автоматично. Однак, якщо подія запускається лише за тригером, вона не може бути запущена автоматично, що призводить до створення помилки.</li>
                <li><code>Event is set to trigger every day.</code> – Це трапляється, коли для події істинне все наступне:
                    <ul>
                        <li>Подію можна запустити автоматично. Іншими словами, <code>is_triggered_only = yes</code> відсутній у події.</li>
                        <li>Середній час до настання події становить 1 день або менше. Якщо його пропущено, вважається 1 день.</li>
                        <li>Подія може спрацювати більше одного разу. Іншими словами, <code>fire_only_once = yes</code> відсутній у події.</li>
                    </ul>
                    Ця помилка попереджає гравця, що подія може спрацьовувати щодня, як тільки <code>trigger = { ... }</code> оцінюється як істинний у перевірці, що відбувається кожні 20 днів. Щоб усунути помилку, будь-яку з трьох необхідних умов можна зробити неістинною для події. Наприклад, у багатьох випадках можна зробити так, щоб подія не запускалася автоматично, а замість цього використовувати блок ефектів для її запуску, наприклад, за допомогою <code>on_actions</code>.</li>
                <li><code>Malformed token: event_id.123, near line</code> на рядку, що вказує ID події – Це трапляється, якщо простір імен події не було додано належним чином.</li>
                <li><code>Failed to create id 12300000 50. Already exists in game. This might crash the game. Reverse id lookup: id 12300000 = my_namespace.0</code> – Зауважте, що це та сама помилка, розділена на дві, а не дві окремі помилки, як може здатися на перший погляд. Це означає, що внутрішній ID події використовується 2 або більше подіями. Існують такі причини появи цієї помилки:
                    <ul>
                        <li>Помилкове розміщення 2 подій з абсолютно однаковим ID – <code>id = my_namespace.0</code> включено до двох подій одночасно. Це самоочевидно.</li>
                        <li>Використання нецілочисельних значень як числового ID після простору імен – Одна подія має <code>id = my_namespace.abc</code>, інша — <code>id = my_namespace.cba</code>. Через те, як гра генерує внутрішні ID, нечисловий ID не підтримується, завжди стаючи числом 0. Таким чином, це абсолютно однакові ID, навіть якщо вони виглядають по-різному.</li>
                        <li>Використання числового ID, не меншого за 100000 – Дві події в різних просторах імен отримали однакові внутрішні ID. Завдяки тому, як гра генерує внутрішні ID, кожному простору імен присвоюється 100000 числових ID, від 0 до 99999. Усе, що більше, почне зазіхати на ID інших просторів імен. Гра повністю дозволяє такі великі числа як числові ID, тому подія може працювати, але дублікат внутрішнього ID означає, що існує пара подій, які розглядаються як одна й та сама подія, тобто одна з них запускатиме іншу.</li>
                    </ul>
                    Оскільки зворотний пошук ID не завжди надається, спосіб визначити, чи пов'язано це з подією, — це друге число: 50 означає, що це пов'язано з подією, тоді як інше число означає інший запис бази даних, наприклад, 54 означає ID лідерів країн, а 55 — ID лідерів підрозділів, числові застарілі ID, які непотрібні через систему персонажів, введену в 1.11.</li>
            </ul>
            
            <hr>
            <h2 id="event-file-example">4. Приклад файлу події</h2>
            <pre><code>add_namespace = my_event
add_namespace = my_hidden_event

country_event = {
    id = my_event.1
    title = my_event.1.t
    desc = my_event.1.desc
    
    is_triggered_only = yes
    
    option = {
        name = my_event.1.a
        add_political_power = 100
    }
}

add_namespace = my_news_event
news_event = {
    id = my_news_event.1
    title = {
        text = my_news_event.1.t.a
        trigger = {
            tag = POL
        }
    }
    title = {
        text = my_event.1.t
    }
    desc = {
        text = my_news_event.1.desc.a
        trigger = {
            tag = POL
        }
    }
    desc = {
        text = my_event.1.desc
    }
    
    picture = GFX_my_news_event_picture
    
    is_triggered_only = yes
    major = yes
    
    option = {
        name = my_news_event.1.a
        trigger = {
            tag = POL
        }
    }
    
    option = {
        name = my_news_event.1.b
        trigger = {
            NOT = { tag = POL }
        }
    }
    
    option = {
        name = my_news_event.1.c
        original_recipient_only = yes
    }
}

country_event = {
    id = my_hidden_event.1
    
    trigger = {
        has_country_flag = event_happened
        country_exists = BHR
    }
    
    mean_time_to_happen = {
        days = 10
        months = 2
        years = 1
        modifier = {
            base = 300
            country_exists = QAT
        }
        modifier = {
            add = 10
            country_exists = OMA
        }
    }
    
    fire_only_once = yes
    hidden = yes
    
    immediate = {
        random_country = {
            limit = {
                is_neighbor_of = BHR
            }
            annex_country = {
                target = BHR
                transfer_troops = yes
            }
        }
    }
}

state_event = {
    id = my_event.2
    title = my_event.2.t
    desc = my_event.2.desc
    picture = GFX_my_event_picture
    
    trigger = {
        ROOT = {
            has_country_flag = fire_this_event
        }
    }
    is_triggered_only = yes
    
    option = {
        name = my_event.2.a
        transfer_state_to = ROOT
    }
    
    option = {
        name = my_event.2.b
        ai_chance = {
            base = 0        # Ніколи не обирати цю опцію.
        }
        transfer_state_to = FROM
    }
}</code></pre>

            <h3 id="integration-on-actions-event">4.1. Інтеграція з on_actions</h3>
            <p><strong>Див. також: <a href="https://hoi4.paradoxwikis.com/On_actions" target="_blank" rel="noopener noreferrer">On actions</a></strong></p>
            <p>Це основні типи подій, які запускаються через <code>on_actions</code>:</p>
            <pre><code>add_namespace = on_action_events
news_event = {      # Новинна подія про захоплення міста
    id = on_action_events.1
    title = on_action_events.1.t    # Падіння Гізи
    desc = on_action_events.1.desc
    
    is_triggered_only = yes
    major = yes
    
    option = {
        trigger = {
            OR = {
                tag = EGY
                is_in_faction_with = EGY 
                is_subject_of = EGY
            }
        }
        name = on_action_events.1.a
    }
    
    option = {
        trigger = {
            NOT = {
                tag = EGY
                is_in_faction_with = EGY 
                is_subject_of = EGY
            }
        }
        name = on_action_events.1.b
    }
}

country_event = {       # Запускається в певний день, якщо умови виконані
    id = on_action_events.2
    title = on_action_events.2.t
    desc = on_action_events.2.desc
    
    is_triggered_only = yes                     # Запобігає автоматичному запуску.
    trigger = {
        has_completed_focus = BHR_focus_name    # Якщо фокус не завершено, ніколи не спрацює.
    }
    
    option = {
        name = on_action_events.2
    }
}

country_event = {       # Інші типи on_actions
    id = on_action_events.3 # У цьому випадку, запит при анексії країни з опцією її звільнення.
    title = on_action_events.3.t
    desc = on_action_events.3.desc
    
    is_triggered_only = yes                     # Запобігає автоматичному запуску.  
    
    trigger = {     # Якщо всі корінні штати FROM є корінними або заявленими ROOT, ніколи не має з'являтися.
        NOT = {     # Запускається всередині random_events = { ... } в on_annex, тому має той самий FROM, що й on_action
            any_state = {
                NOT = {
                    is_core_of = ROOT
                    is_claimed_by = ROOT
                }
                is_core_of = FROM
            }
        }
        FROM = {
            NOT = {
                tag = GER       # Має окрему подію
            }
        }
    }
    
    option = {
        name = on_action_events.3.a   # "Звільнити [FROM.GetName] як маріонетку"
        every_owned_state = {
            limit = {
                is_core_of = FROM 
                NOT = {
                    is_core_of = ROOT
                    is_claimed_by = ROOT
                }
            }
            transfer_state_to = FROM
        }
        if = {
            limit = {
                has_dlc = "Together for Victory"
            }
            set_autonomy = {
                target = FROM
                autonomy_state = autonomy_integrated_puppet
            }
        }
        else = {
            puppet = FROM
        }
    }
    
    option = {
        name = on_action_events.3.b # "Не звільняти [FROM.GetName]"
        add_stability = -0.1
        add_war_support = -0.1
    }
}</code></pre>
            <p>Щоб це запустити, потрібно створити код у будь-якому файлі <code>/Hearts of Iron IV/common/on_actions/*.txt</code>, іноді в поєднанні з булевими прапорами, щоб запобігти їх повторному запуску, якщо <code>fire_only_once</code> неможливий. У наведеному вище прикладі буде використано таке:</p>
            <pre><code>on_actions = {
    on_state_control_changed = {
        effect = {
            if = {
                limit = {
                    FROM.FROM = {
                        state = 999 # Власний ID штату. Гра вилетить, якщо не існує.
                    }
                    NOT = {
                        has_global_flag = giza_fall # Щоб запобігти подвійному запуску.
                    }                               # Через 'major = yes', fire_only_once НЕ спрацює
                }
                news_event = { id = on_action_events.1 hours = 6 random_hours = 3 } # Запускається через 6-9 годин, щоб виглядати природніше.
            }
        }
    }
    on_startup = {
        effect = {
            BHR = {
                country_event = { 
                    id = on_action_events.2 
                    days = 357  
                    random_days = 7     # Запускається в останній тиждень 1936 року, припускаючи стандартну дату початку.
                }
            }
        }
    }
    on_annex = {
        random_events = {
            1 = on_action_events.3
        }
    }
}</code></pre>

            <h3 id="integration-history-event">4.2. Інтеграція з історією</h3>
            <p><strong>Див. також: <a href="https://hoi4.paradoxwikis.com/Country_creation#History" target="_blank" rel="noopener noreferrer">Створення країни#Історія</a></strong></p>
            <p>Альтернативно, ви можете запустити подію всередині файлу <code>/Hearts of Iron IV/history/countries/*.txt</code>:</p>
            <pre><code># history/countries/BHR - Bahrain.txt
# Інший код пропущено
country_event = { 
    id = on_action_events.2 
    days = 357  
    random_days = 7     # Запускається в останній тиждень 1936 року, припускаючи стандартну дату початку.
}</code></pre>

            <hr>
            <h2 id="notes-references-event">5. Примітки та посилання</h2>
            <p><sup>[a]</sup> Подія із затримкою</p>
            <p><sup>[1]</sup> `NEngine::PINGER_EVENT_DELAY_DAYS` (20 днів) в defines.</p>
            <p><sup>[2]</sup> `NEngine::EVENT_TIMEOUT_DAYS` (13 днів) в defines.</p>

        </div> <!-- кінець #main-content -->
        
        <hr> 

        <!-- Фокусоване навігаційне меню (таке ж, як на головній сторінці) -->
        <nav id="focused-navigation-menu" class="focused-navigation">
            <h2>Основні розділи в роботі</h2>
            <p class="focused-nav-description">Швидкий доступ до сторінок, що зараз створюються та перекладаються.</p>
            <div class="focused-nav-links">
                <a href="decisions" class="nav-card"> 
                    <span class="nav-card-title">Decisions</span>
                    <span class="nav-card-description">(Рішення)</span>
                </a>
                <a href="events" class="nav-card current-page-link"> 
                    <span class="nav-card-title">Events</span>
                    <span class="nav-card-description">(Події)</span>
                </a>
                <a href="ideas" class="nav-card"> 
                    <span class="nav-card-title">Ideas</span>
                    <span class="nav-card-description">(Ідеї)</span>
                </a>
                <a href="national_focuses" class="nav-card"> 
                    <span class="nav-card-title">National focuses</span>
                    <span class="nav-card-description">(Національні фокуси)</span>
                </a>
            </div>
        </nav>
    </div> <!-- кінець .container -->

    <footer>
        <p>Переклад сторінки Event modding - Hearts of Iron 4 Wiki. Оригінал: <a href="https://hoi4.paradoxwikis.com/Event_modding" target="_blank" rel="noopener noreferrer">hoi4.paradoxwikis.com/Event_modding</a></p>
        <p>Дизайн та переклад (за допомогою ШІ) адаптовано для особистого використання.</p>
    </footer>
</div> <!-- кінець .page-wrapper -->

    <script>
        const themeSwitcher = document.getElementById('theme-switcher');
        const body = document.body;
        const defaultBaseClass = 'theme-dark-base'; 

        function applyTheme(themeName) {
            body.classList.remove('theme-light', 'theme-aistudio-dark', 'theme-nord-dark', 'theme-dracula', 'theme-one-dark-pro', defaultBaseClass);

            if (themeName === 'theme-light') {
                body.classList.add('theme-light');
            } else {
                body.classList.add(defaultBaseClass); 
                body.classList.add(themeName);       
            }
            if (themeSwitcher) {
                 themeSwitcher.value = themeName;
            }
            localStorage.setItem('theme', themeName); 
        }
        
        const savedTheme = localStorage.getItem('theme') || 'theme-light';
        applyTheme(savedTheme);

        if (themeSwitcher) {
            themeSwitcher.addEventListener('change', function() {
                applyTheme(this.value);
            });
        }
        
        function switchLanguage(lang) {
            const currentPage = window.location.pathname.split("/").pop(); 
            let targetPage = '';
            let baseName = currentPage;

            if (currentPage.includes('_uk.html')) {
                baseName = currentPage.replace('_uk.html', '');
            } else if (currentPage.includes('_ru.html')) {
                baseName = currentPage.replace('_ru.html', '');
            } else if (currentPage.endsWith('.html')) { 
                 baseName = currentPage.substring(0, currentPage.length - 5);
            }
             if (baseName === 'index' || baseName === '') baseName = 'index'; 

            if (lang === 'uk') {
                targetPage = (baseName === 'index') ? 'index.html' : `${baseName}_uk.html`;
                if ( (currentPage === targetPage && baseName !== 'index') || (currentPage === 'index.html' && baseName === 'index') ) {
                     alert('Ви вже на українській версії.'); return;
                }
            } else if (lang === 'ru') {
                targetPage = (baseName === 'index') ? 'index_ru.html' : `${baseName}_ru.html`;
                 if (currentPage === targetPage) {
                     alert('Ви вже на російській версії.'); return;
                 }
            }
            
            if (targetPage) {
                window.location.href = targetPage;
            }
        }

        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                try {
                    const targetElement = document.querySelector(targetId);
                    if (targetElement) {
                        const topBarHeight = document.querySelector('.top-bar')?.offsetHeight || 0;
                        const elementPosition = targetElement.getBoundingClientRect().top;
                        const offsetPosition = elementPosition + window.pageYOffset - topBarHeight - 15; 

                        window.scrollTo({
                            top: offsetPosition,
                            behavior: 'smooth'
                        });

                         if(history.pushState && targetId !== "#") { 
                            history.pushState(null, null, targetId);
                        } else if (targetId !== "#") {
                            location.hash = targetId;
                        }
                    } else {
                        console.warn("Елемент для прокрутки не знайдено:", targetId);
                    }
                } catch (error) {
                     console.warn("Помилка при виборі елемента для прокрутки:", targetId, error);
                }
            });
        });

        var scrollTopButton = document.getElementById("scrollTopBtn");
        if (!scrollTopButton) { // Створюємо кнопку, якщо її ще немає
            scrollTopButton = document.createElement("button");
            scrollTopButton.innerHTML = "↑";
            scrollTopButton.id = "scrollTopBtn";
            scrollTopButton.title = "Нагору";
            scrollTopButton.onclick = function() {
                window.scrollTo({top: 0, behavior: 'smooth'});
            };
            document.body.appendChild(scrollTopButton);
        }

        window.onscroll = function() {
            if (scrollTopButton) { // Перевіряємо, чи існує кнопка
                if (document.body.scrollTop > 100 || document.documentElement.scrollTop > 100) {
                    scrollTopButton.style.display = "block";
                } else {
                    scrollTopButton.style.display = "none";
                }
            }
        };
    </script>
</body>
</html>