<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Модинг Національних Фокусів HOI4</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto:wght@700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="./styles/styles.css"> 
</head>
<body class="theme-light theme-dark-base"> 
<div class="page-wrapper">
    <div class="top-bar">
        <div class="controls">
            <label for="language-switcher">Мова:</label>
            <select id="language-switcher" onchange="switchLanguage(this.value)">
                <option value="uk" selected>Українська</option>
                <option value="ru">Русский</option> 
            </select>

            <label for="theme-switcher">Тема:</label>
            <select id="theme-switcher">
                <option value="theme-light">Світла</option>
                <option value="theme-aistudio-dark">AI Studio Dark</option>
                <option value="theme-nord-dark">Nord Dark</option>
                <option value="theme-dracula">Dracula</option>
                <option value="theme-one-dark-pro">One Dark Pro</option>
            </select>
        </div>
        <div class="quick-nav-link">
            <a href="./index" class="nav-button">← Головна сторінка</a> 
            <a href="#header-text" class="nav-button">Вгору &#x2191;</a>
            <a href="#focused-navigation-menu" class="nav-button">Меню розділів &#x2193;</a>
        </div>
    </div>

    <header>
        <h1 id="header-text">Модинг нац. фокусів (Focuses)</h1>
    </header>

    <div class="container">
        <div class="disclaimer">
            <p><strong>Увага!</strong> Це переклад оригінальної сторінки <a href="https://hoi4.paradoxwikis.com/National_focus_modding" target="_blank" rel="noopener noreferrer">National focus modding - Hearts of Iron 4 Wiki</a>.</p>
            <p>Я не є автором оригінального контенту. Переклад виконано за допомогою інструментів штучного інтелекту та може містити неточності. Оригінал знаходиться за вказаним посиланням.</p>
        </div>

        <div id="main-content">
            <p>Дерева національних фокусів визначаються у файлах <code>/Hearts of Iron IV/common/national_focus/*.txt</code>. Як і більшість інших файлів, назва файлу не має значення і використовується лише для організації. Один файл може містити більше одного дерева фокусів або жодного.</p>

            <div class="table-of-contents">
                <h3>Зміст</h3>
                <ul>
                    <li><a href="#focus-tree">1. Дерево фокусів</a>
                        <ul>
                            <li><a href="#examples-tree">1.1. Приклади</a></li>
                            <li><a href="#shortcuts-tree">1.2. Ярлики</a></li>
                            <li><a href="#inlay-window-tree">1.3. Вбудоване вікно</a>
                                <ul>
                                    <li><a href="#definition-inlay">1.3.1. Визначення</a></li>
                                    <li><a href="#declaration-inlay">1.3.2. Оголошення</a></li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><a href="#national-focuses">2. Національні фокуси</a>
                        <ul>
                            <li><a href="#name-description-focus">2.1. Назва та опис</a></li>
                            <li><a href="#position-focus">2.2. Позиція</a></li>
                            <li><a href="#interaction-focuses">2.3. Взаємодія з іншими фокусами</a></li>
                            <li><a href="#icon-focus">2.4. Іконка</a></li>
                            <li><a href="#dynamic-appearance-focus">2.5. Динамічний вигляд</a></li>
                            <li><a href="#triggers-focus">2.6. Тригери</a></li>
                            <li><a href="#effects-focus">2.7. Ефекти</a></li>
                            <li><a href="#search-filters-focus">2.8. Фільтри пошуку</a></li>
                            <li><a href="#titlebar-styles-focus">2.9. Стилі заголовків</a></li>
                            <li><a href="#ai-will-do-focus">2.10. Що робитиме ШІ</a>
                                <ul>
                                    <li><a href="#formulas-chance-focus">2.10.1. Формули для розрахунку шансу</a></li>
                                </ul>
                            </li>
                            <li><a href="#other-focus">2.11. Інше</a></li>
                            <li><a href="#examples-focus">2.12. Приклади</a></li>
                        </ul>
                    </li>
                    <li><a href="#shared-focuses">3. Спільні фокуси</a>
                        <ul>
                            <li><a href="#joint-focuses">3.1. Спільні (Joint) фокуси</a></li>
                            <li><a href="#example-shared">3.2. Приклад</a></li>
                        </ul>
                    </li>
                    <li><a href="#continuous-focuses">4. Безперервні фокуси</a>
                        <ul>
                            <li><a href="#focus-palettes">4.1. Палітри фокусів</a></li>
                            <li><a href="#focuses-continuous">4.2. Фокуси</a></li>
                        </ul>
                    </li>
                    <li><a href="#ai-strategy-plans">5. Плани стратегії ШІ</a>
                        <ul>
                            <li><a href="#example-ai-plan">5.1. Приклад</a></li>
                        </ul>
                    </li>
                    <li><a href="#notes-focus">6. Примітки</a></li>
                    <li><a href="#references-focus">7. Посилання</a></li>
                </ul>
            </div>
            
            <h2 id="focus-tree">1. Дерево фокусів</h2>
            <p><em>Це вікі, що підтримується спільнотою. Якщо ви помітили помилку, будь ласка, допоможіть її виправити.</em></p>
            <p>Дерево фокусів визначається за допомогою блоку <code>focus_tree = { ... }</code>. Використовуються наступні аргументи:</p>
            <ul>
                <li><code>id = my_focus_tree</code> визначає ID, який використовує дерево фокусів. Його визначення є обов'язковим, і збіг призведе до помилки. ID в основному використовується для тригера <code>has_focus_tree</code> та ефекту <code>load_focus_tree</code>, підказки яких використовують його як ключ локалізації.</li>
                <li><code>country = { ... }</code> — це блок MTTH (Середній час до настання події), який присвоює оцінку дереву фокусів, визначаючи, яке з них використовується в грі. Це оцінюється перед початком гри, і перевірка практично ніколи не оновлюється<sup>[a]</sup>. Дерево фокусів з найвищою оцінкою буде завантажено для країни. За замовчуванням оцінка починається з 1. Типове використання виглядає так:
                <pre><code>country = {
    factor = 0
    modifier = {
        add = 20
        original_tag = TRA
    }
}</code></pre>
                У цьому випадку країни, що походять від Трансільванії (тобто сама країна та будь-які відгалуження громадянської війни або колабораціоністського уряду, як це забезпечується тригером <code>original_tag</code>), матимуть оцінку 20, тоді як усі інші країни матимуть оцінку 0. Припускаючи, що немає іншого дерева фокусів, де Трансільванія має вищу оцінку країни, це забезпечить завантаження цього дерева фокусів для неї.</li>
                <li><code>default = yes</code> встановлює дерево фокусів як стандартне. Загалом, має бути одне стандартне дерево фокусів, не більше і не менше. Дерево фокусів, позначене як стандартне, означає, що якщо всі інші дерева фокусів мають оцінку країни 0, замість них буде обрано це дерево. Крім того, країна, що починає з деревом фокусів, не з'явиться в розділі "малі країни" в меню "цікаві країни" перед початком гри. Якщо це пропущено в дереві фокусів, воно вважається нестандартним.</li>
                <li><code>reset_on_civilwar = no</code> не визначається за своїм ефектом. Натомість, так обробляються дерева фокусів у громадянських війнах, незалежно від того, чи встановлено <code>reset_on_civilwar</code> і як саме:
                <br>Коли починається громадянська війна, початкова країна завжди продовжуватиме використовувати дерево фокусів. Фокус, який вона виконує, не буде призупинено або скасовано самою громадянською війною. Для повстанця дерево фокусів, яке він використовує, буде оцінено на початку громадянської війни, призначаючи одне залежно від значення <code>country = { ... }</code> кожного дерева. Якщо для повстанської країни використовується те саме дерево фокусів, що й для початкової країни на момент початку громадянської війни, кожен фокус, завершений початковою країною, буде завершено для повстанської країни, включаючи встановлення того ж прогресу фокуса для того, що виконується початковою країною на даний момент. В іншому випадку прогрес фокуса буде втрачено.</li>
                <li><code>shared_focus = TAG_focusname</code> встановлює, що дерево фокусів включатиме вказаний спільний фокус та кожен фокус, пов'язаний з ним через передумови. Встановлення цього на неіснуючий фокус спричиняє аварійне завершення гри при завантаженні в головне меню.</li>
                <li><code>continuous_focus_position = { x = 1200 y = 100 }</code> — це позиція верхнього лівого кута меню безперервних фокусів у пікселях. Для порівняння, за замовчуванням<sup>[b]</sup>, палітра безперервних фокусів має позицію 50 по осі X та 1000 по осі Y. Якщо обидва x та y встановлені на 0 або позиція не визначена для дерева, вона скидається до стандартної позиції.</li>
                <li><code>initial_show_position = { ... }</code> визначає початкову позицію камери при першому відкритті дерева фокусів. Існує 2 способи її організації:
                    <ul>
                        <li><code>focus = TAG_focusname</code> змусить камеру центруватися на вказаному фокусі зокрема. Він буде точно у верхньому центрі екрана, враховуючи зсуви.</li>
                        <li><code>x = 12 y = 0</code> визначає точну позицію верхнього центру камери. Це використовує ту саму систему координат, що й звичайні фокуси, за замовчуванням одиниця x дорівнює 96 пікселям, а одиниця y — 130 пікселям<sup>[c]</sup>.</li>
                    </ul>
                Це також приймає <code>offset = { ... }</code>, додаючи вказані значення до відповідних позицій, якщо умови в блоці тригерів <code>trigger = { ... }</code> виконані для країни. Наприклад, це застосує модифікатор і призведе до позиції x = 13, y = 1, якщо країна — BHR:
                <pre><code>initial_show_position = {
    x = 17
    y = 0
    offset = {
        x = -4
        y = 1
        trigger = {
            tag = BHR
        }
    }
}</code></pre></li>
                <li><code>focus = { ... }</code> — це самі фокуси. Кожен фокус, розміщений у дереві фокусів, буде. Фокуси повинні знаходитися всередині <code>focus_tree = { ... }</code>, щоб гра знала, до якого саме дерева фокусів їх призначити. Якщо блок <code>focus = { ... }</code> опиняється поза <code>focus_tree = { ... }</code> або всередині іншого <code>focus = { ... }</code>, це позначається в лозі помилок як "focus" будучи неочікуваним токеном, що виправляється коригуванням дужок за потреби.</li>
            </ul>

            <h3 id="examples-tree">1.1. Приклади</h3>
            <p>Чистий мінімум, з 2 фокусами: <button class="spoiler-button" onclick="toggleSpoiler(this)">Показати/Сховати</button></p>
            <div class="spoiler-content" style="display:none;">
            <pre><code>focus_tree = {
    id = example_tree_min
    country = { factor = 0 modifier = { add = 10 original_tag = ENG } } # Тільки для Англії
    default = no

    focus = {
        id = ENG_min_focus_1
        icon = GFX_goal_unknown # Припускаємо, що GFX_goal_unknown_shine існує
        x = 0
        y = 0
        cost = 10 # 70 днів

        completion_reward = {
            add_political_power = 50
        }
    }
    focus = {
        id = ENG_min_focus_2
        icon = GFX_goal_unknown
        x = 0
        y = 1
        cost = 10
        prerequisite = { focus = ENG_min_focus_1 }

        completion_reward = {
            add_stability = 0.05
        }
    }
}</code></pre>
            </div>

            <p>Середнє дерево, з 2 фокусами: <button class="spoiler-button" onclick="toggleSpoiler(this)">Показати/Сховати</button></p>
            <div class="spoiler-content" style="display:none;">
            <pre><code>focus_tree = {
    id = example_tree_avg
    country = {
        factor = 0
        modifier = { add = 10 original_tag = GER }
    }
    default = no
    continuous_focus_position = { x = 0 y = 5 } # Зміщуємо безперервні фокуси вниз
    initial_show_position = { focus = GER_avg_focus_1 }

    focus = {
        id = GER_avg_focus_1
        icon = GFX_goal_rhineland # Припускаємо, що GFX_goal_rhineland_shine існує
        x = 2
        y = 0
        cost = 10
        available_if_capitulated = yes

        available = {
            num_of_civilian_factories > 15
        }
        bypass = {
            num_of_military_factories > 20
        }
        
        completion_reward = {
            add_political_power = 75
            add_named_threat = { threat = 2 name = GER_avg_focus_1 } # Додає 2 світової напруги
        }
    }

    focus = {
        id = GER_avg_focus_2
        icon = GFX_goal_anschluss
        relative_position_id = GER_avg_focus_1 # Позиція відносно попереднього
        x = 0 # Тобто, під ним
        y = 1 
        cost = 10
        
        mutually_exclusive = { focus = GER_another_path_focus } # Приклад взаємовиключного фокуса
        prerequisite = { focus = GER_avg_focus_1 }

        complete_tooltip = { # Показуємо лише спрощену підказку
            add_political_power = 25
            AUS = { country_event = { id = generic.1 days = 1 } } # generic.1 це аншлюс Австрії
        }
        completion_reward = { # Фактичні ефекти
            hidden_effect = { add_political_power = 25 }
            AUS = { country_event = { id = generic.1 days = 1 } }
        }
    }
}</code></pre>
            </div>

            <h3 id="shortcuts-tree">1.2. Ярлики</h3>
            <p>Ярлики використовуються для додавання навігаційних кнопок у нижньому лівому куті, які при натисканні переміщують камеру до певного фокуса.</p>
            <p>Параметри:</p>
            <ul>
                <li><code>name = lockey</code>, локалізована назва, яка буде відображатися на кнопці.</li>
                <li><code>target = focus_id</code>, фокус, до якого слід перемістити камеру.</li>
                <li><code>scroll_wheel_factor = <float></code>, масштабування, чим вище значення, тим більше масштабування (між 0 та 1).</li>
                <li><code>trigger = { ... }</code>, блок тригерів, що визначає, чи повинна бути видима кнопка ярлика, опціонально. (Якщо істинно, це не перевизначить умови дозволу цільового фокуса.)</li>
            </ul>
            <p>Приклад визначення ярлика:</p>
            <pre><code>shortcut = {
  name = GER_oppose_hitler_shortcut
  target = GER_oppose_hitler_ww 
  scroll_wheel_factor = 0.485
  trigger = {
    has_dlc = "Gotterdammerung"
  }
}</code></pre>

            <h3 id="inlay-window-tree">1.3. Вбудоване вікно</h3>
            <p>Вбудовані вікна фокусів — це загальні вбудовані компоненти, які можна додати до дерева фокусів, подібно до вікна безперервних фокусів, об'єкта скриптового GUI. Наразі підтримують лише відображення інформації та жодної взаємодії.</p>

            <h4 id="definition-inlay">1.3.1. Визначення</h4>
            <p>Визначення для вбудованих вікон знаходяться в <code>/Hearts of Iron IV/common/focus_inlay_windows/*.txt</code>.</p>
            <p>Для посібника, написаного розробниками гри, див. <a href="https://forum.paradoxplaza.com/forum/developer-diary/dev-diary-modding.1584260/" target="_blank" rel="noopener noreferrer">Щоденник розробників | Модинг</a>.</p>
            <p>Параметри:</p>
            <ul>
                <li><code>window_name = gui_component_name</code> назва скриптового GUI, який слід використовувати.</li>
                <li><code>internal = <bool></code> якщо істинно, то вбудоване вікно видно лише самій країні (за замовчуванням <code>no</code>).</li>
                <li><code>visible = { ... }</code> чи повинно бути видиме вбудоване вікно, коли невидиме, жодних оцінок не буде зроблено.</li>
                <li><code>scripted_images = { ... }</code> список зображень, які повинні мати динамічні спрайти.
                    <ul>
                        <li><code><icon_name> = { ... }</code> назва іконки (повинна бути підкомпонентом "gui_component_name"). Список можливих gfx для іконки, вибирається перший, що оцінюється як істинний.
                            <ul>
                                <li><code><gfx_name> = { ... }/yes</code> Якщо надано тригер, він буде оцінений з областю видимості країни дерева фокусів. Якщо встановлено "yes", він завжди буде використовуватися. Примітка: "yes" зазвичай є останнім записом у списку, який діє як стандартний випадок.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
            <p>Приклад визначення вбудованого вікна:</p>
            <pre><code>inlay_window_id = {
  window_name = gui_component_name
  internal = yes
  visible = {
    visibility_triggers
  }
  scripted_images = {
    advisor_portrait = {
      gfx_name = {
        has_completed_focus = TAG_focus_name_example
      }
      gfx_name_fallback = yes
    }
  }
}</code></pre>

            <h4 id="declaration-inlay">1.3.2. Оголошення</h4>
            <p>Вбудоване вікно повинно бути оголошено в дереві фокусів. Для дерева фокусів можна визначити будь-яку кількість вбудованих вікон.</p>
            <p>Параметри:</p>
            <ul>
                <li><code>id = inlay_window_id</code> ідентифікатор вбудованого вікна.</li>
                <li><code>position = { x = <int> y = <int> }</code> позиція на дереві, той самий синтаксис та масштаб, що й позиція безперервного фокуса.</li>
            </ul>
            <p>Приклад оголошення вбудованого вікна:</p>
            <pre><code>inlay_window = {
  id = ger_inner_circle_inlay_window
  position = { x = 4500 y = 1150 }
}</code></pre>

            <hr>
            <h2 id="national-focuses">2. Національні фокуси</h2>
            <p><em>Це вікі, що підтримується спільнотою. Якщо ви помітили помилку, будь ласка, допоможіть її виправити.</em></p>
            <p>ID для фокуса визначається за допомогою <code>id = TAG_focusname</code>. Хоча необов'язково додавати префікс тегу країни до ID фокуса, це краще робити, щоб уникнути збігу ID фокусів з різних дерев фокусів. Наявність однакового ID фокуса в різних деревах фокусів призводить до помилок, таких як пошкоджені лінії передумов та ефекти або тригери, наприклад <code>complete_national_focus</code> або <code>has_completed_focus</code>, що не працюють коректно. Замість цього можна використовувати спільні фокуси, щоб розмістити той самий фокус у різних деревах фокусів.</p>

            <h3 id="name-description-focus">2.1. Назва та опис</h3>
            <p>Назва фокуса залежно від увімкненої мови визначається в <code>/Hearts of Iron IV/localisation/</code>, використовуючи ID фокуса як ключ локалізації. Зокрема, для англійської мови це визначається в будь-якому файлі <code>/Hearts of Iron IV/localisation/english/*_l_english.yml</code> з кодуванням UTF-8-BOM. Бажано використовувати нові файли локалізації, коли це можливо, замість перезапису файлів базової гри, щоб не доводилося змінювати це для сумісності з останніми версіями, і для цього файл повинен мати нову назву, якої немає в базовій грі, але він все одно повинен закінчуватися на <code>_l_english.yml</code>, щоб правильно завантажуватися. ID фокуса використовується як ключ локалізації для встановлення назви увімкненою мовою, тоді як опис використовує ID фокуса з доданим <code>_desc</code>:</p>
            <pre><code>l_english:
 TAG_focus_name: "Приклад фокуса"
 TAG_focus_name_desc: "Опис прикладу фокуса"</code></pre>

            <h3 id="position-focus">2.2. Позиція</h3>
            <p>Позиція фокуса визначається за допомогою атрибутів <code>x = 5</code> та <code>y = 1</code>. За замовчуванням одиниця <code>x</code> дорівнює 96 пікселям, а одиниця <code>y</code> — 130 пікселям<sup>[c]</sup>. Іншими словами, фокус безпосередньо під іншим фокусом мав би різницю в 1 одиницю по <code>y</code>, тоді як фокус безпосередньо праворуч від іншого мав би різницю в 2 одиниці по <code>x</code>. За замовчуванням це відносно верхнього лівого кута дерева: більше значення <code>x</code> зміщує фокус праворуч, більше значення <code>y</code> — вниз.</p>
            <p>Також можливо і бажано (для фокусів з передумовами) зробити позицію фокуса відносною до іншого фокуса за допомогою <code>relative_position_id = TAG_other_focus</code>. Це позиціонуватиме фокус відносно цього фокуса, додаючи значення <code>x</code> та <code>y</code> до позиції іншого фокуса (після розрахунку його власного <code>relative_position_id</code>). Це дозволяє більшу гнучкість у дизайні дерева фокусів, дозволяючи легко змінювати позицію всієї гілки одночасно завдяки оновленню позиціонування дочірніх фокусів. Це також дозволяє використовувати пізніший <code>offset = { ... }</code> лише у верхньому фокусі кожної гілки, яку потрібно перемістити. Наприклад, якщо фокус A має <code>x = 1 y = 2</code>, фокус B позиціонується відносно фокуса A і має <code>x = 3 y = 4</code>, то фокус B буде розташований загалом на 4 кроки праворуч і 6 кроків вниз від верхнього лівого кута. Фокус C, позиціонований відносно фокуса B при <code>x = -1 y = 1</code>, тоді буде розташований на 3 кроки праворуч і 7 кроків вниз від верхнього лівого кута. Гра може поводитися нестабільно при неправильному ID відносної позиції. Рекурсія (наприклад, фокус, позиціонований відносно самого себе, або фокус A та фокус B, позиціоновані відносно один одного) може спричинити аварійне завершення гри, оскільки неможливо визначити точну позицію фокуса, і фокус також повинен знаходитися в тому ж дереві фокусів, щоб аргумент працював належним чином.</p>
            <p>Зміна позиції фокуса на основі виконання умови робиться за допомогою <code>offset = { ... }</code>. Значення <code>x = 10</code> та <code>y = -3</code> будуть додані до позиції фокуса, якщо умови в <code>trigger = { ... }</code> виконані для країни при завантаженні дерева фокусів. Це виглядає так:</p>
            <pre><code>offset = {
    x = -5
    trigger = {
        has_dlc = "Poland: United and Ready"
    }
}</code></pre>
            <p>Це, зокрема, перемістить фокус на 5 одиниць вліво, якщо увімкнено DLC "Poland: United and Ready". Цю перевірку також можна оновити під час сесії за допомогою ефекту <code>mark_focus_tree_layout_dirty</code><sup>[d]</sup>, застосовуючи зсув, якщо істинно.</p>

            <h3 id="interaction-focuses">2.3. Взаємодія з іншими фокусами</h3>
            <p><code>prerequisite = { focus = TAG_other_focus }</code> визначає фокуси, необхідні для завершення, щоб цей фокус став доступним. Щонайменше один фокус у передумові повинен бути завершений, щоб позначити передумову як істинну, і кожна передумова повинна бути завершена, щоб взяти фокус. Якщо жодна з передумов не знаходиться в тому ж дереві фокусів, то фокус не з'явиться. Іншими словами, оператор АБО робиться шляхом розміщення 2 фокусів усередині передумови як <code>prerequisite = { focus = TAG_other_focus_1 focus = TAG_other_focus_2 }</code>, тоді як оператор І робиться шляхом розміщення двох різних передумов наступним чином:</p>
            <pre><code>prerequisite = { focus = TAG_other_focus_1 }
prerequisite = { focus = TAG_other_focus_2 }</code></pre>
            <p>Ця система не може представити кожне булеве логічне розташування, таке як A ∨ (B ∧ C) (де A, B і C представляють, чи завершено фокус) або з чимось, що використовує заперечення. У цьому випадку можна замість цього поставити оператор АБО для будь-якого з фокусів, необхідних для завершення цього, і використовувати тригер <code>has_completed_focus</code> у блоці <code>available = { ... }</code> з необхідними інструментами керування потоком. Можна використовувати власну підказку тригера, щоб гравцеві було легше зрозуміти.</p>
            <p><code>mutually_exclusive = { focus = TAG_other_focus }</code> робить цей фокус неможливим для вибору, якщо вказаний фокус було завершено. Якщо обидва фокуси взаємовиключні один до одного, то стрілки взаємної виключності будуть показані у вікні дерева фокусів. Взаємна виключність до кількох фокусів зазвичай робиться шляхом розміщення кількох <code>focus = TAG_focusname</code> в одному <code>mutually_exclusive</code>, але визначення кількох <code>mutually_exclusive</code> також можливе.</p>
            <p>Ні передумови, ні взаємна виключність не вимагають, щоб інший фокус знаходився в тому ж дереві фокусів. Це означає, що його можна використовувати зі спільними фокусами для оголошення звичайного, неспільного фокуса як взаємовиключного або передумови без будь-яких помилок, навіть якщо використовується в дереві фокусів, що не містить цього фокуса.</p>
            <p>Різниця між передумовами та використанням <code>has_completed_focus</code> у блоці <code>available = { ... }</code> полягає в тому, що передумови відображаються як лінії у вікні дерева національних фокусів і відображаються окремо від інших тригерів у підказці фокуса.</p>
            <p>Існує проблема, яка призводить до неправильної роботи ліній передумов: дублікати ID фокусів у різних деревах фокусів. У цьому випадку гра може прийняти позицію фокусів як позицію в іншому дереві фокусів, що містить ті самі фокуси, що призводить до того, що вони, здається, пов'язані з порожніми місцями або починаються всередині них. Це також може зламати алгоритм генерації шляху та змусити його використовувати неправильні спрайти поворотів, які відображатимуться пошкодженими навіть у деревах, які не мають дублікатів. Щоб уникнути цього, слід уникати дублікатів ID фокусів. Простий спосіб значно зменшити ймовірність — це додавати префікс ID фокусів тегом країни (наприклад, <code>TAG_focus_name</code>) або чимось іншим, унікальним для дерева фокусів (наприклад, <code>REGION_focus_name</code> для спільного регіонального дерева). Якщо одне й те саме дерево фокусів слід використовувати для кількох країн, це можна зробити, маючи лише одне дерево фокусів, де <code>country = { ... }</code> дерева налаштовано так, щоб бажання його використовувати було найвищим для кількох країн замість однієї; якщо одну й ту саму гілку дерева фокусів слід використовувати в кількох різних деревах фокусів, то спільні фокуси можуть досягти саме цього.</p>
            <p>Крім того, гра передбачає, що передумова фокуса розміщена над фокусом, який її вимагає, і вона не може правильно згенерувати шлях до фокуса в іншому випадку, що відображатиметься як шлях, що використовує неправильні спрайти на поворотах у 90°.</p>

            <h3 id="icon-focus">2.4. Іконка</h3>
            <h4>Загальний огляд спрайтів</h4>
            <p>Для завантаження GFX гра використовує систему спрайтів. Спрайти — це визначення в коді, які прив'язують назву до файлу зображення, а також опціонально додають додаткову інформацію, таку як анімація, кількість кадрів, спосіб завантаження зображення тощо. Це означає, що розміщення зображення в папці gfx недостатньо для його роботи, спрайт також повинен використовувати цей файл зображення.</p>
            <p>Спрайти визначаються в будь-якому файлі <code>/Hearts of Iron IV/interface/*.gfx</code> (це окремо від <code>gfx/interface/</code>), який відкривається текстовим редактором. Щоб створити новий файл <code>.gfx</code>, можна створити текстовий файл і перейменувати його, змінивши розширення (у Windows Провідник повинен показувати розширення, що він не робить за замовчуванням). Зокрема, спрайти визначаються всередині блоку <code>spriteTypes = { ... }</code>, щоб відокремити їх від шрифтів та стрілок на карті, які також визначаються в цій папці, тоді як найпростіший спрайт з найменшою кількістю обов'язкових властивостей — це <code>spriteType = { ... }</code>. Найпростіше визначення спрайта виглядає так:</p>
            <pre><code>spriteTypes = {
    spriteType = {
        name = GFX_first_sprite                         # У деяких випадках початок з GFX_ є обов'язковим для роботи.
        texturefile = gfx/interface/folder/filename.dds # Папка та назва файлу не мають значення, доки вони правильні
    }                                                   # Для розділення папок можна використовувати лише пряму косу риску '/' (може бути подвоєна як '//').
    spriteType = {                                      # Зображення не обов'язково має бути .dds, оскільки .tga та .png є прийнятними.
        name = GFX_second_sprite
        texturefile = gfx/interface/folder2/filename2.dds
        noOfFrames = 2 # Розділяє зображення на 2 половини, між якими можна динамічно перемикатися в GUI
    }
}</code></pre>
            <p>У цьому випадку створюється спрайт з назвою <code>GFX_first_sprite</code>, до якого прив'язується зображення <code>/Hearts of Iron IV/gfx/interface/folder/filename.dds</code>, і аналогічно другий спрайт. Другий спрайт буде розділений на 2 кадри: це визначається тим, що ліва половина зображення є першим кадром, а права половина — другим (більше кадрів далі розділятимуть зображення горизонтально). Це не робить спрайт анімованим, лише вмикає опцію перемикання між двома половинами за потреби. <code>GFX_second_sprite:1</code> служить посиланням на перший кадр, і GUI можна налаштувати для зміни показаного кадру залежно від контексту, наприклад, з радіостанціями. Щоб додати анімацію, використовується <code>frameAnimatedSpriteType</code>.</p>
            <p>Ніколи не є обов'язковим копіювати файл базової гри для зміни спрайта. Якщо є дублікати визначень спрайта з однаковою назвою в різних файлах, гра надасть пріоритет тому, який буде оцінено пізніше, на основі назви файлу, а старіший спрайт буде повністю проігноровано. Це можна забезпечити, починаючи назву файлу заміни символом, що знаходиться пізно в таблиці символів ASCII. Зазвичай для цієї мети використовується мала літера 'z'. Наприклад, щоб змінити кількість кадрів у <code>GFX_idea_traits_strip</code> на 10, можна визначити спрайт з такою назвою з 10 кадрами у файлі мода <code>modname/interface/zz_replace.gfx</code> замість копіювання файлу базової гри. Оскільки більшість файлів <code>.gfx</code> визначають невід'ємні частини користувацького інтерфейсу, їх копіювання може призвести до того, що завантажені файли мода втратять спрайти після великого оновлення гри, що відображатиметься в грі як стандартне зображення, яким за замовчуванням є собака помилок. Щоб полегшити тягар необхідності перевіряти файли інтерфейсу, найкраще ніколи не копіювати файли <code>.gfx</code>, якщо тільки додаткові зміни не будуть активно шкідливими для мода, як, наприклад, з <code>interface/subuniticons.gfx</code>.</p>
            <p>У фокусі іконка призначається рядком <code>icon = GFX_focus_icon</code>. Це призначає два спрайти фокусу, зокрема:</p>
            <ul>
                <li>Звичайний спрайт з назвою <code>GFX_focus_icon</code>. Використовується у вікні опису фокуса та у вікні дерева фокусів, коли фокус недоступний, виконується або був завершений.</li>
                <li>Спрайт для анімації блиску з назвою <code>GFX_focus_icon_shine</code> (з <code>_shine</code> в кінці). Використовується у вікні дерева фокусів для фокусів, які наразі доступні, та у вікнах політики країни та дипломатії для фокуса, який наразі виконується. Оскільки гра не використовує назви файлів при оцінці, розміщення визначення <code>spriteType</code> у файлі з "shine" у назві не є ні необхідним, ні достатнім. Використовується лише назва спрайта, яка повинна бути такою ж, як у звичайного спрайта, з доданим <code>_shine</code> в кінці. Найпоширеніша помилка, коли блиск не працює, — це недотримання цього правила іменування.</li>
            </ul>
            <p>Якщо один з них не визначено або визначено неправильно, замість відповідного спрайта буде використано іконку відсутності фокуса <code>Goal unknown.png</code>, однак робочий спрайт продовжуватиме використовуватися. Якщо <code>texturefile</code> посилається на неіснуючий файл, чи то неправильний шлях до папки<sup>[e]</sup>, чи назва файлу, включаючи розширення, іконка фокуса відображатиметься повністю прозорою. За замовчуванням базова гра зберігає зображення для іконок фокусів у папці <code>/Hearts of Iron IV/gfx/interface/goals/</code> та спрайти у файлах <code>interface/goals.gfx</code> та <code>interface/goals_shine.gfx</code>. Оскільки немає причин копіювати файли до мода, і це призведе до необхідності оновлювати файл після великого оновлення для використання нових спрайтів, найкраще створити новий файл у папці для визначень спрайтів. Нижче наведено приклад файлу інтерфейсу, який визначає обидва спрайти:</p>
            <p>Приклад файлу інтерфейсу: <button class="spoiler-button" onclick="toggleSpoiler(this)">Показати/Сховати</button></p>
            <div class="spoiler-content" style="display:none;">
            <pre><code>spriteTypes = {
    spriteType = {
        name = "GFX_focus_example"
        texturefile = "gfx/interface/goals/focus_example.dds"
    }
    # Спрайт блиску
    spriteType = {
        name = "GFX_focus_example_shine"
        texturefile = "gfx/interface/goals/focus_example_shine.dds"
        effectFile = "gfx/FX/buttonstate.lua" # Це стандартний файл ефекту для блиску
        animation = {
            animationmaskfile = "gfx/interface/goals/focus_example_shine.dds" # Маска повинна бути тим самим зображенням
            animationtexturefile = "gfx/interface/goals/shine_overlay.dds" # Стандартне зображення накладання блиску
            animationrotation = -90.0
            animationlooping = no
            animationtime = 0.75
            animationdelay = 0
            animationblendmode = "add"
            animationtype = "scrolling"
            animationrotationoffset = { x = 0.0 y = 0.0 }
            animationtexturescale = { x = 1.0 y = 1.0 } 
        }
        animation = {
            animationmaskfile = "gfx/interface/goals/focus_example_shine.dds"
            animationtexturefile = "gfx/interface/goals/shine_overlay.dds"
            animationrotation = 90.0
            animationlooping = no
            animationtime = 0.75
            animationdelay = 0
            animationblendmode = "add"
            animationtype = "scrolling"
            animationrotationoffset = { x = 0.0 y = 0.0 }
            animationtexturescale = { x = 1.0 y = 1.0 } 
        }
        legacy_lazy_load = no
    }
}</code></pre>
            </div>
            <p>При копіюванні з шаблону зауважте, що потрібно змінити <code>animationmaskfile</code> в кожній анімації всередині спрайта з блиском разом з <code>texturefile</code> та <code>name</code>.</p>

            <h3 id="dynamic-appearance-focus">2.5. Динамічний вигляд</h3>
            <p><code>dynamic = yes</code> дозволяє назві та іконці фокуса бути динамічними. Зокрема, це дозволяє використовувати скриптовану локалізацію в назвах фокусів та динамічну іконку. Якщо <code>false</code> або не встановлено, це все одно дозволить їх використовувати, але замість цього він обере одну на початку гри і ніколи не змінить її.</p>
            <p>Динамічні іконки обробляються подібно до назв або описів подій: замість одного <code>icon = GFX_focus_example</code> фокус може містити кілька <code>icon = { ... }</code> одночасно, кожне з унікальним тригером. У фокусі буде використано першу можливу іконку. <code>icon = { ... }</code> складається з <code>trigger = { ... }</code>, який повинен бути виконаний країною, щоб іконка була обрана, та <code>value = GFX_focus_example</code>, який визначає 2 спрайти, що використовуються для фокуса.</p>
            <p>Приклад визначення динамічного фокуса, з усіма іншими опціональними аргументами пропущеними:</p>
            <pre><code>focus = {
    id = TAG_political_focus # У локалізації, TAG_political_focus: "[THIS.GetRulingIdeology] політичний фокус"
    icon = {
        trigger = { has_government = democratic }
        value = GFX_focus_example_democratic
    }
    icon = {
        value = GFX_focus_example_fallback
    }
    dynamic = yes
}</code></pre>

            <h3 id="triggers-focus">2.6. Тригери</h3>
            <p><strong>Див. також: <a href="https://hoi4.paradoxwikis.com/Triggers" target="_blank" rel="noopener noreferrer">Тригери</a></strong></p>
            <p>Щоб взяти фокус, крім передумов фокуса, повинні бути виконані умови в блоці <code>available = { ... }</code>. Це функціонує як блок І, тому кожен з тригерів повинен бути істинним для виконання. Області видимості можна використовувати для перевірки умов для інших країн або всередині штатів. За замовчуванням область видимості — це країна, що виконує фокус. Наприклад, цей приклад вимагає, щоб країна мала більше 10% стабільності, а штат 294 належав Катару:</p>
            <pre><code>available = {
    stability > 0.1
    294 = { is_owned_by = QAT }
}</code></pre>
            <p><code>bypass = { ... }</code> схожий, але для обходу фокуса. Обхід фокуса позначає фокус як завершений, але не надає його ефектів у нагороді за завершення, замість цього фокус може мати <code>bypass_effect = { ... }</code>. Те саме стосується й <code>available</code>: це блок І, який за замовчуванням передбачає країну, що виконує фокус. <code>bypass_if_unavailable = yes</code> можна використовувати, щоб фокус автоматично обходився, як тільки блок <code>available = { ... }</code> не виконується, без необхідності переносити тригери.</p>
            <p><code>allow_branch = { ... }</code> використовується, щоб вказати, коли фокус повинен бути видимим. Це перевіряється лише при першому завантаженні дерева фокусів. Однак цю перевірку також можна оновити під час сесії за допомогою ефекту <code>mark_focus_tree_layout_dirty</code><sup>[d]</sup>, роблячи фокус видимим або невидимим залежно від того, чи він істинний чи ні. За замовчуванням фокус також буде заборонено, якщо будь-який з батьківських фокусів (встановлених передумовами) заборонено. Однак фокус, що містить <code>allow_branch</code> у своєму визначенні, перевірятиме лише свій власний статус дозволу, все ще відображаючись, якщо він має заборонених батьків. Це означає, що якщо гілка налаштована на заборону за певних умов, перший фокус у будь-якій підгілці, яка має власні умови для дозволу, також повинен містити умову батьківської гілки всередині себе, тоді як інші фокуси можуть взагалі не мати визначеного <code>allow_branch</code>, оскільки він успадковується від батьків.</p>
            <p><code>available_if_capitulated = yes</code> встановлює, що фокус можна завершити під час капітуляції. За замовчуванням це встановлено на <code>false</code>.</p>
            <p><code>cancel_if_invalid = no</code> та <code>continue_if_invalid = yes</code> визначають, як обробляти фокус, якщо блок <code>available = { ... }</code> стає хибним під час його виконання. За замовчуванням вони істинні та хибні відповідно. Якщо обидва встановлені на <code>false</code>, фокус призупиниться, коли блок <code>available = { ... }</code> буде хибним. Це не видалить статичний модифікатор <code>gain_focus</code>, який за замовчуванням призводить до витрати 1 політичної влади на день при виконанні фокуса.</p>
            <p><code>cancel = { ... }</code> визначає додаткові умови, які скасують фокус, якщо будуть виконані. Зазвичай це поєднується з <code>cancel_if_invalid = no</code>.</p>
            <p><code>historical_ai = { ... }</code> визначає, коли ШІ може обрати цей фокус з увімкненим історичним фокусом. Це не гарантує, що він обере цей фокус, а скоріше запобігає його вибору, коли хибно. Це має пріоритет над порядком фокусів, наданим у планах стратегії ШІ: якщо ШІ мав би виконати цей фокус наступним за планом, але <code>historical_ai = { ... }</code> хибно, а історичний фокус увімкнено, то він не зможе цього зробити.</p>

            <h3 id="effects-focus">2.7. Ефекти</h3>
            <p><strong>Див. також: <a href="https://hoi4.paradoxwikis.com/Effects" target="_blank" rel="noopener noreferrer">Ефекти</a></strong></p>
            <p>Основна нагорода фокуса виконується за допомогою <code>completion_reward = { ... }</code>. Це виконує кожен ефект у вказаних областях видимості в тому порядку, в якому вони розміщені у файлі. Передбачувана область видимості — це країна, що виконує фокус. Наприклад, це додасть 100 політичної влади країні, що виконує фокус, і запустить подію країни <code>my_event.0</code> для Оману:</p>
            <pre><code>completion_reward = {
    add_political_power = 100
    OMA = { country_event = my_event.0 }
}</code></pre>
            <p>Підказку фокуса можна змінити за допомогою <code>complete_tooltip = { ... }</code>, який також є блоком ефектів. Це було б еквівалентно розміщенню вмісту нагороди всередині <code>hidden_effect</code> та використанню <code>effect_tooltip</code> у тій самій нагороді. Це може бути корисно, якщо підказка нагороди виглядає захаращеною. Наприклад, триразове використання <code>random_owned_controlled_state</code> з тим самим ефектом у кожному може призвести до захаращеної підказки, оскільки кожен штат та його ефекти відображатимуться окремо. Але якщо замість цього код встановлює прапор штату для кожного штату в нагороді, а в підказці використовує <code>every_state</code>, обмежений тими, що мають прапор штату, він покаже той самий ефект, що виконується для 3 штатів одночасно, скорочуючи його до третини від того, що було.</p>
            <p>Крім того, <code>select_effect = { ... }</code> використовується для виконання ефекту при виборі фокуса. Це не має підказки, що відображається гравцеві. Це також автоматично робить фокус неможливим для скасування вручну. Його все ще можна скасувати автоматично, якщо налаштовано на це, тому в більшості випадків краще встановити його так, щоб він не скасовувався, якщо недійсний, щоб запобігти багаторазовому спрацьовуванню ефектів усередині, оскільки немає способу виконати ефект при скасуванні фокуса.</p>
            <p>Крім того, <code>bypass_effect = { ... }</code> використовується для виконання ефекту при обході фокуса.</p>
            <p>Фокус ще не позначено як завершений під час виконання ефектів. Це означає, що будь-яка перевірка <code>has_completed_focus</code>, запущена всередині, поверне <code>false</code>. У деяких випадках це може бути перешкодою, найчастіше при використанні <code>allow_branch</code> (оскільки ефект для оновлення перевірки не працюватиме належним чином, якщо розміщений у фокусі). Можна розглянути деякі альтернативи:</p>
            <ul>
                <li>Прапори країни для відстеження завершення фокуса. Оскільки прапори країни встановлюються негайно, доки встановлення передує вимозі, це працюватиме.</li>
                <li>Затримка ефектів, які вимагатимуть завершення фокуса. Зазвичай це робиться шляхом запуску прихованої події. Якщо зроблено без затримки, подія буде запущена одразу після завершення фокуса, що не призведе до помітної затримки для гравця, але все одно виконає ефекти по порядку.</li>
                <li>Примусове позначення фокуса як завершеного. Це, наприклад, можна зробити за допомогою <code>load_focus_tree</code> для того ж дерева фокусів із збереженням завершених фокусів. Це не перерве виконання нагороди за завершення.</li>
            </ul>

            <h3 id="search-filters-focus">2.8. Фільтри пошуку</h3>
            <p><em>Це вікі, що підтримується спільнотою. Якщо ви помітили помилку, будь ласка, допоможіть її виправити.</em></p>
            <p>Фільтри пошуку для кожного фокуса встановлюються за допомогою <code>search_filters = { ... }</code>. У цьому блоці кожен фільтр пошуку, який має фокус, розміщується всередині, розділений пробілами. Наприклад, наступне призначить <code>FOCUS_FILTER_MANPOWER</code> та <code>FOCUS_FILTER_POLITICAL</code> фокусу: <code>search_filters = { FOCUS_FILTER_MANPOWER FOCUS_FILTER_POLITICAL }</code>. Ці фільтри використовуються в меню пошуку у верхньому правому куті вікна дерева національних фокусів.</p>
            <p>Фільтр фокуса не визначається в жодному файлі, а створюється динамічно для кожного дерева фокусів. Кожен з них використовує спрайт такий самий, як його назва, але з доданим <code>GFX_</code> на початку. Наприклад, це визначення в будь-якому файлі <code>/Hearts of Iron IV/interface/*.gfx</code> буде використано для <code>FOCUS_FILTER_MY_MOD</code>:</p>
            <pre><code>spriteType = {
    name = GFX_FOCUS_FILTER_MY_MOD
    texturefile = gfx/interface/focusview/filter/my_mod_icon.dds
}</code></pre>
            <p>Як і раніше зі звичайною іконкою фокуса, точна папка, де зберігаються іконки фільтрів, не має значення, доки <code>texturefile</code>, вказаний у спрайті, правильний.</p>
            <p>Ключ локалізації, що використовується для фільтра фокуса, такий самий, як його назва. Наприклад, з попереднім прикладом <code>FOCUS_FILTER_MY_MOD</code>, це буде визначено для англійської мови в будь-якому файлі <code>/Hearts of Iron IV/localisation/english/*_l_english.yml</code> як <code>FOCUS_FILTER_MY_MOD: "Мій мод"</code>.</p>
            <p>Список усіх фільтрів фокусів базової гри: <button class="spoiler-button" onclick="toggleSpoiler(this)">Показати/Сховати</button></p>
            <div class="spoiler-content" style="display:none;">
            <ul>
                <li><code>FOCUS_FILTER_POLITICAL</code></li>
                <li><code>FOCUS_FILTER_RESEARCH</code></li>
                <li><code>FOCUS_FILTER_INDUSTRY</code></li>
                <li><code>FOCUS_FILTER_STABILITY</code></li>
                <li><code>FOCUS_FILTER_WAR_SUPPORT</code></li>
                <li><code>FOCUS_FILTER_MANPOWER</code></li>
                <li><code>FOCUS_FILTER_ANNEXATION</code></li>
                <li><code>FOCUS_FILTER_TFV</code> (Together for Victory)</li>
                <li><code>FOCUS_FILTER_DOD</code> (Death or Dishonor)</li>
                <li><code>FOCUS_FILTER_WTT</code> (Waking the Tiger)</li>
                <li><code>FOCUS_FILTER_MTG</code> (Man the Guns)</li>
                <li><code>FOCUS_FILTER_LR</code> (La Résistance)</li>
                <li><code>FOCUS_FILTER_BFTB</code> (Battle for the Bosporus)</li>
                <li><code>FOCUS_FILTER_NSB</code> (No Step Back)</li>
                <li><code>FOCUS_FILTER_BBA</code> (By Blood Alone)</li>
                <li><code>FOCUS_FILTER_AAT</code> (Arms Against Tyranny)</li>
                <li><code>FOCUS_FILTER_TOA</code> (Trial of Allegiance)</li>
            </ul>
            </div>
            <p>Крім того, можна встановити пріоритет фільтрів фокусів. Це робиться за допомогою блоку <code>search_filter_prios = { ... }</code> поза <code>focus_tree = { ... }</code>. Цей пріоритет неможливо встановити специфічно для дерева фокусів, він є глобальним. Запис у цьому блоці виконується у форматі <code>FOCUS_FILTER_MY_MOD = 1200</code>, де перша частина визначає фільтр, а друга — пріоритет. Фільтри фокусів з вищим пріоритетом з'являються раніше у верхньому вікні. За замовчуванням гра робить це у файлі, що містить загальне дерево фокусів: <code>/Hearts of Iron IV/common/national_focus/generic.txt</code>.</p>

            <h3 id="titlebar-styles-focus">2.9. Стилі заголовків</h3>
            <p>Стилі використовуються для визначення зображення, що використовується для заголовка, фону, на якому відображається назва фокуса. Заголовок встановлюється за допомогою <code>text_icon = mod_focus_style</code> у фокусі.</p>
            <p>Стиль, який можна використовувати у фокусах, створюється за допомогою блоку <code>style = { ... }</code> на кореневому рівні у файлі <code>/Hearts of Iron IV/common/national_focus/*.txt</code>, за замовчуванням <code>00_titlebar_styles.txt</code>. Ось можливі атрибути, які можна використовувати всередині стилю:</p>
            <ul>
                <li><code>name = example_style</code> — назва стилю. Аргумент визначає, що потрібно написати в <code>text_icon</code> фокуса, щоб посилатися на цей стиль.</li>
                <li><code>default = yes</code>, якщо написано, змусить будь-який фокус без визначеного <code>text_icon</code> використовувати цей стиль. Лише один стиль загалом може використовувати це.</li>
                <li><code>unavailable = GFX_focus_unavailable_example</code> — спрайт, що використовується, коли фокус недоступний.</li>
                <li><code>completed = GFX_focus_unavailable_example</code> — спрайт, що використовується, коли фокус було завершено.</li>
                <li><code>available = GFX_focus_unavailable_example</code> — спрайт, що використовується, коли фокус доступний для завершення, але ще не вибраний.</li>
                <li><code>current = GFX_focus_unavailable_example</code> — спрайт, що використовується, коли фокус наразі виконується.</li>
            </ul>
            <p>Приклад визначення стилю:</p>
            <pre><code>style = {
    name = example_style
    unavailable = GFX_focus_unavailable_example
    completed = GFX_focus_completed_example
    available = GFX_focus_can_start_example
    current = GFX_focus_current_example
}</code></pre>
            <p>Приклади визначень спрайтів: <button class="spoiler-button" onclick="toggleSpoiler(this)">Показати/Сховати</button></p>
            <div class="spoiler-content" style="display:none;">
            <pre><code>spriteTypes = {
    spriteType = {
        name = "GFX_focus_unavailable_example"
        texturefile = "gfx/interface/goals/focus_unavailable_bg.dds" 
    }
    spriteType = {
        name = "GFX_focus_completed_example"
        texturefile = "gfx/interface/goals/focus_completed_bg.dds" 
    }
    spriteType = {
        name = "GFX_focus_can_start_example"
        texturefile = "gfx/interface/goals/focus_available_bg.dds"
    }
    spriteType = {
        name = "GFX_focus_current_example"
        texturefile = "gfx/interface/goals/focus_current_bg.dds"
    }
}</code></pre>
            </div>

            <h3 id="ai-will-do-focus">2.10. Що робитиме ШІ</h3>
            <p><code>ai_will_do = { ... }</code> — це блок MTTH, який визначає ймовірність того, що ШІ виконає цей фокус, якщо не встановлено план стратегії ШІ. За замовчуванням кожен фокус має оцінку 1. Аргументи <code>base</code> (зміна значення), <code>add</code> та <code>factor</code> (множення його) можна використовувати для її зміни. У блоці <code>ai_will_do = { ... }</code>, <code>modifier = { ... }</code> функціонує як блок тригерів, де також підтримуються попередні три аргументи, що змінюють значення. Значення буде змінено, якщо тригери істинні. Наприклад, наступне призведе до значення 15 для POL та значення 5 для кожної іншої країни:</p>
            <pre><code>ai_will_do = {
    base = 5
    modifier = {
        factor = 3
        tag = POL
    }
}</code></pre>
            <p>До <code>ai_will_do</code> можна додати довільно велику кількість модифікаторів, і вони застосовуватимуться в тому порядку, в якому вони розміщені в коді. Також можна використовувати змінні всередині модифікатора значення <code>ai_will_do</code>.</p>
            <p>Спосіб оцінки значення для вибору фокуса ШІ полягає в тому, що при виборі фокуса для виконання він генерує випадкове десяткове значення між 0 та значенням <code>ai_will_do</code> для кожного з фокусів. Якщо оцінюваний фокус має фокус-передумову, який ШІ щойно завершив, згенероване значення <code>ai_will_do</code> множиться на 1.5 перед тим, як гра обере фокус.<sup>[1]</sup> Якщо план стратегії ШІ, якого наразі дотримується країна, має визначені <code>focus_factors = { ... }</code> для цього фокуса, значення множиться на вказане значення. Після цього гра обирає фокус, який має найвище згенероване значення. Якщо жоден з фокусів не має значення вище 0, ШІ не обере жодного з них, замість цього переходячи до безперервних фокусів, якщо можливо, або не роблячи нічого в іншому випадку. Через цей алгоритм низькі значення менш імовірні для вибору, ніж підказує інтуїція.</p>
            <p>Ще раз, це оцінюється лише якщо план стратегії ШІ для країни не має встановленого порядку фокусів або якщо жоден з фокусів у цьому порядку не може бути виконаний. Порівняння шансів між фокусами таке:</p>

            <h4 id="formulas-chance-focus">2.10.1. Формули для розрахунку шансу</h4>
            <p>Оскільки загальна формула може бути складною для розрахунку без спеціального інструменту, простіші розрахунки для особливих випадків можуть бути досить корисними: чи то для наближення шансу шляхом підстановки схожих чисел, чи для розрахунку точного шансу, якщо числа збігаються. Кожен випадок буде надано з трьома абзацами — Формула в першому абзаці, приклад у другому абзаці та загальне пояснення, чому це застосовується (хоча не обов'язково суворе доведення) у третьому абзаці. Загальний шанс буде надано за шкалою 0—1; передбачається, що фокуси мають позитивне значення, оскільки негативні значення непередбачені, а фокус із шансом нуль ніколи не буде обраний ШІ гри, що означає, що їх можна виключити з розрахунку повністю; а модифікатори, що застосовуються до значення "ШІ зробить" фокуса (наприклад, з планів стратегії ШІ або бонус за продовження тієї ж гілки), вже застосовані, оскільки множення результату кинутих кубиків на число було б таким самим, як множення кінців діапазону на це число. У скороченій формі значення ai_will_do фокуса буде просто називатися "значенням фокуса".</p>
            
            <p>Один фокус з великим значенням та інші фокуси з однаковим меншим значенням: <button class="spoiler-button" onclick="toggleSpoiler(this)">Показати/Сховати</button></p>
            <div class="spoiler-content" style="display:none;">
            <p>Якщо є один фокус (назвемо його L) з великим значенням (V<sub>L</sub>) та N інших фокусів (назвемо їх S<sub>i</sub>) з однаковим меншим значенням (V<sub>S</sub>), то шанс вибору фокуса L становить (V<sub>L</sub> - V<sub>S</sub>) / V<sub>L</sub> + (N * V<sub>S</sub><sup>2</sup>) / (2 * V<sub>L</sub><sup>2</sup>), тоді як шанс вибору будь-якого конкретного фокуса S<sub>i</sub> становить V<sub>S</sub><sup>2</sup> / (2 * V<sub>L</sub><sup>2</sup>).</p>
            <p>Наприклад, нехай один фокус має значення 4, а 2 інших фокуси мають значення 1. Тоді шанс вибору великого фокуса становить (4-1)/4 + (2 * 1<sup>2</sup>)/(2 * 4<sup>2</sup>) = 3/4 + 2/32 = 24/32 + 2/32 = 26/32, або 81.25%. Тим часом, шанс кожного з двох інших фокусів становить 1<sup>2</sup>/(2*4<sup>2</sup>) = 1/32, або 3.125%.</p>
            <p>Це тому, що якщо випадкове число, згенероване для фокуса L, вище, ніж V<sub>S</sub>, то він автоматично перемагає кожен фокус S<sub>i</sub>, оскільки їхнє максимальне можливе значення — V<sub>S</sub>. Це трапляється з імовірністю (V<sub>L</sub> - V<sub>S</sub>) / V<sub>L</sub>. В іншому випадку, якщо це нижче, то кожен фокус має однакову ймовірність бути обраним, як і у випадку двох фокусів з однаковим значенням, описаному далі.</p>
            </div>

            <p>Фокуси, розділені на два різні значення: <button class="spoiler-button" onclick="toggleSpoiler(this)">Показати/Сховати</button></p>
            <div class="spoiler-content" style="display:none;">
            <p>Якщо є N<sub>1</sub> фокусів зі значенням V<sub>1</sub> та N<sub>2</sub> фокусів зі значенням V<sub>2</sub>, припускаючи V<sub>1</sub> > V<sub>2</sub>, то шанс вибору будь-якого конкретного фокуса зі значенням V<sub>1</sub> становить (V<sub>1</sub> - V<sub>2</sub>) / (N<sub>1</sub> * V<sub>1</sub>) + (N<sub>1</sub> * V<sub>1</sub><sup>2</sup> + N<sub>2</sub> * V<sub>2</sub><sup>2</sup>) / (2 * N<sub>1</sub> * V<sub>1</sub><sup>2</sup>) * (V<sub>2</sub> / V<sub>1</sub>)<sup>N<sub>1</sub></sup>. Тим часом, шанс вибору будь-якого конкретного фокуса зі значенням V<sub>2</sub> становить (N<sub>1</sub> * V<sub>1</sub><sup>2</sup> + N<sub>2</sub> * V<sub>2</sub><sup>2</sup>) / (2 * N<sub>2</sub> * V<sub>1</sub><sup>2</sup>) * (V<sub>2</sub> / V<sub>1</sub>)<sup>N<sub>1</sub></sup>.</p>
            <p>Наприклад, якщо 2 фокуси мають значення 3, а 3 фокуси мають значення 2. Тоді шанс кожного з фокусів зі значенням 3 становить (3-2)/(2*3) + (2*3<sup>2</sup> + 3*2<sup>2</sup>)/(2*2*3<sup>2</sup>) * (2/3)<sup>2</sup> ≈ 1/6 + (18+12)/36 * 4/9 ≈ 0.166 + 30/36 * 4/9 ≈ 0.166 + 5/6 * 4/9 ≈ 0.166 + 10/27 ≈ 0.166 + 0.37 ≈ 53.6%. Тим часом, шанс кожного з фокусів зі значенням 2 становить (2*3<sup>2</sup> + 3*2<sup>2</sup>)/(2*3*3<sup>2</sup>) * (2/3)<sup>2</sup> ≈ (18+12)/54 * 4/9 ≈ 30/54 * 4/9 ≈ 5/9 * 4/9 ≈ 20/81 ≈ 24.6%.</p>
            <p>Це працює аналогічно попередньому випадку.</p>
            </div>

            <p>Загальна формула: <button class="spoiler-button" onclick="toggleSpoiler(this)">Показати/Сховати</button></p>
            <div class="spoiler-content" style="display:none;">
            <p>Для загального випадку шанс того, що фокус X буде обраний, становить ∫<sub>0</sub><sup>V<sub>X</sub></sup> ( Π<sub>i≠X</sub> (y/V<sub>i</sub>) ) * (1/V<sub>X</sub>) dy, де V<sub>X</sub> — значення фокуса X, V<sub>i</sub> — значення кожного іншого фокуса i, а y — змінна інтегрування, що представляє значення, згенероване для фокуса X.</p>
            </div>

            <h3 id="other-focus">2.11. Інше</h3>
            <p>Ще одним важливим аспектом фокуса є <code>cost = 8</code>. Це встановлює, скільки часу потрібно для завершення фокуса. За замовчуванням вартість 1 приймається за 7 "очок",<sup>[2]</sup> з яких за замовчуванням 1 завершується щодня, хоча можна встановити різні швидкості залежно від того, чи перебуває країна у стані війни чи миру.<sup>[3]</sup> Іншими словами, вартість 1 за замовчуванням представляє тиждень. Десяткові значення у <code>cost</code> підтримуються, і в грі вони будуть округлені до цілого дня.</p>
            <p><code>will_lead_to_war_with = TAG</code> використовується для позначення фокуса як такого, що веде до війни з вказаною країною. Це відображатиметься для вказаної країни та її союзників (суб'єктів, сюзерена та/або членів тієї ж фракції) як виправдання країною, що виконує фокус, приводу для війни проти них на верхній панелі сповіщень. Це також змушує ШІ готуватися до потенційної війни, як для країни, що виконує фокус, так і для країни, на яку фокус налаштований оголосити війну.</p>
            <p><code>cancelable = no</code> встановить, що фокус неможливо скасувати вручну без визначення <code>select_effect</code>. Це не запобігає автоматичному скасуванню фокуса. Однак <code>cancelable = yes</code> не робить фокус можливим для ручного скасування, якщо фокус також містить <code>select_effect = { ... }</code>.</p>

            <h3 id="examples-focus">2.12. Приклади</h3>
            <p>Чистий мінімум (на верхівці гілки): <button class="spoiler-button" onclick="toggleSpoiler(this)">Показати/Сховати</button></p>
            <div class="spoiler-content" style="display:none;">
            <pre><code>focus = {
    id = ENG_example_min_top
    icon = GFX_goal_unknown # Передбачається, що GFX_goal_unknown_shine існує
    x = 0
    y = 0
    cost = 1 # 7 днів

    completion_reward = {
        add_stability = 0.01
    }
}</code></pre>
            </div>
            <p>Середні фокуси: <button class="spoiler-button" onclick="toggleSpoiler(this)">Показати/Сховати</button></p>
            <div class="spoiler-content" style="display:none;">
            <pre><code>focus = { # Відносний фокус, який також має зсув
    id = ENG_example_avg_relative_offset
    icon = GFX_goal_generic_major_power
    relative_position_id = ENG_example_min_top
    x = 2 # На 2 праворуч від ENG_example_min_top
    y = 0 # На тому ж рівні, що й ENG_example_min_top

    offset = { # Якщо Англія не є великою державою, змістити на 1 вниз
        y = 1
        trigger = { NOT = { is_major = yes } }
    }

    prerequisite = { focus = ENG_example_min_top }
    cost = 5 # 35 днів
    available_if_capitulated = yes

    completion_reward = {
        add_war_support = 0.05
    }
}
focus = { # Фокус, який обходиться, якщо виконано інший фокус
    id = ENG_example_avg_bypass
    icon = GFX_goal_support_democracy
    x = 0
    y = 1 # Під ENG_example_min_top
    cost = 1
    
    prerequisite = { focus = ENG_example_min_top }
    bypass = { has_completed_focus = ENG_example_avg_relative_offset } # Якщо відносний фокус завершено, цей обходиться

    completion_reward = { 
        if = {
            limit = { پول = { has_government = democratic } }
            add_relations = { target = POL value = 20 }
        }
    }
}</code></pre>
            </div>
            <p>Фокус <code>allow_branch</code>: <button class="spoiler-button" onclick="toggleSpoiler(this)">Показати/Сховати</button></p>
            <div class="spoiler-content" style="display:none;">
            <pre><code>focus = { # Фокус, який може бути недоступний для деяких країн
    id = ENG_example_allow_branch
    icon = GFX_goal_generic_construct_civ_factory
    x = -2 # На 2 ліворуч від ENG_example_min_top
    y = 0  # На тому ж рівні
    cost = 2

    allow_branch = { # Видно лише якщо Англія не є суб'єктом
        NOT = { is_subject = yes }
    }
    prerequisite = { focus = ENG_example_min_top }

    completion_reward = {
        add_civilian_factory = 1
    }
}</code></pre>
            </div>

            <hr>
            <h2 id="shared-focuses">3. Спільні фокуси</h2>
            <p><em>Це вікі, що підтримується спільнотою. Якщо ви помітили помилку, будь ласка, допоможіть її виправити.</em></p>
            <p>Спільні фокуси — це ті, які можна використовувати в кількох національних деревах фокусів. Приклади включають гілку "Запросити іноземних інвесторів", присутню в деревах фокусів для Китаю, Комуністичного Китаю та Маньчжоу-Го, або гілки національних дерев фокусів "Знову приєднатися до залізниць" та "Відновити робітничу республіку" для Естонії, Латвії та Литви.</p>
            <p>Спільний фокус визначається блоком <code>shared_focus = { ... }</code>, не всередині будь-якого блоку <code>focus_tree = { ... }</code>. У цьому блоці фокус визначається точно так само, як і звичайний фокус у дереві фокусів: кожен з аргументів, які можна використовувати у звичайному <code>focus = { ... }</code>, можна використовувати і в <code>shared_focus = { ... }</code> без будь-яких змін.</p>
            <p>Спільний фокус додається до дерева фокусів шляхом додавання аргументу <code>shared_focus = my_shared_focus</code> всередині цього дерева фокусів. Це додасть вказаний спільний фокус та кожен спільний фокус, пов'язаний з ним через передумови, припускаючи, що <code>allow_branch</code> істинно. Навіть якщо спільний фокус має інший фокус як передумову, який не завантажено в цьому дереві фокусів, він відображатиметься як видимий. Встановлення цього на неіснуючий фокус спричиняє аварійне завершення гри при завантаженні в головне меню. Крім того, відсутність неспільних фокусів у вашому дереві під час додавання спільного фокуса призведе до аварійного завершення.</p>
            <p>Крім того, ефект <code>load_focus_tree</code> можна використовувати із збереженням завершених фокусів таким чином, щоб спільні фокуси зберігалися як завершені при переході до іншого дерева:</p>
            <pre><code>load_focus_tree = {
    tree = my_focus_tree
    keep_completed = yes
}</code></pre>
            <p>Це може слугувати альтернативою використанню <code>allow_branch = { ... }</code> для того, щоб гілки дерева фокусів для однієї країни були видимими або ні.</p>
            <p>Спільні фокуси можна визначати в будь-якому файлі <code>/Hearts of Iron IV/common/national_focus/*.txt</code>. Зазвичай їх зберігають в окремих файлах від дерев фокусів, що їх використовують, але це не обов'язково.</p>

            <h3 id="joint-focuses">3.1. Спільні (Joint) фокуси</h3>
            <p><em>Це вікі, що підтримується спільнотою. Якщо ви помітили помилку, будь ласка, допоможіть її виправити.</em></p>
            <p>Спільні фокуси — це підмножина спільних фокусів, які також ділять завершення фокусів між різними країнами. Ефекти можуть застосовуватися до того, хто завершив, лише до інших країн, або до всіх них.<sup>[4]</sup></p>
            <p>Спільний фокус визначається як блок <code>joint_focus = { ... }</code> на кореневому рівні. Кожен атрибут, можливий для використання у звичайних національних фокусах, також можливий для використання тут, з додатковими змінами та доповненнями:</p>
            <ul>
                <li><code>joint_trigger = { ... }</code> — це блок тригерів, який визначає, які країни вважаються спільними для цього конкретного фокуса. Це перевіряється для кожної країни. Завершення буде спільним для всіх країн.</li>
                <li><code>completion_reward = { ... }</code> функціонує аналогічно звичайним національним фокусам, але виконує ефекти для кожної спільної країни.</li>
                <li><code>completion_reward_joint_originator = { ... }</code> — це нагорода за завершення, що виконується лише для країни, яка безпосередньо завершила фокус.</li>
                <li><code>completion_reward_joint_member = { ... }</code> — це нагорода за завершення, що виконується для кожної країни, де фокус завершено, крім тієї, що безпосередньо його завершила.</li>
            </ul>
            <p>В іншому спільні фокуси ідентичні звичайним спільним фокусам.</p>

            <h3 id="example-shared">3.2. Приклад</h3>
            <p>Текст у цьому розділі за замовчуванням згорнуто. <button class="spoiler-button" onclick="toggleSpoiler(this)">Показати/Сховати</button></p>
            <div class="spoiler-content" style="display:none;">
            <pre><code># Файл: common/national_focus/shared_baltic_focuses.txt
shared_focus = {
    id = BAL_industrial_effort # Спільний для всіх балтійських країн
    icon = GFX_goal_generic_construct_civ_factory
    x = 0
    y = 0
    cost = 10

    completion_reward = {
        add_civilian_factories = 1
    }
}

joint_focus = { # Спільний фокус для відновлення залізниць
    id = BAL_rejoin_railways
    icon = GFX_goal_generic_construct_infrastructure
    x = 0
    y = 1
    cost = 5 # Коротший, бо це спільна робота
    
    prerequisite = { focus = BAL_industrial_effort }

    joint_trigger = { # Лише для Естонії, Латвії, Литви
        OR = {
            original_tag = EST
            original_tag = LAT
            original_tag = LIT
        }
    }

    completion_reward_joint_originator = { # Той, хто завершив, отримує бонус
        add_political_power = 25
    }
    completion_reward_joint_member = { # Інші учасники теж отримують щось
        add_stability = 0.02
    }
    completion_reward = { # Ефект для всіх учасників
        random_owned_state = {
            limit = { is_on_continent = europe } # Приклад обмеження
            add_infrastructure = 1
        }
    }
}

# Файл: common/national_focus/est_focuses.txt
focus_tree = {
    id = estonia_focus
    country = { factor = 0 modifier = { add = 10 original_tag = EST } }
    default = no
    shared_focus = BAL_industrial_effort # Додаємо спільні фокуси

    focus = { # Приклад унікального естонського фокуса
        id = EST_national_identity
        icon = GFX_goal_generic_nationalism_focus
        x = 2 # Поряд зі спільними
        y = 0
        cost = 10
        completion_reward = { add_political_power = 50 }
    }
}
# Подібні файли для Латвії та Литви, які також включають shared_focus = BAL_industrial_effort
</code></pre>
            </div>

            <hr>
            <h2 id="continuous-focuses">4. Безперервні фокуси</h2>
            <p><em>Це вікі, що підтримується спільнотою. Якщо ви помітили помилку, будь ласка, допоможіть її виправити.</em></p>
            <p>Безперервні фокуси визначаються у файлах <code>/Hearts of Iron IV/common/continuous_focus/*.txt</code>. Це фокуси, які можна обрати після завершення 10 національних фокусів<sup>[5]</sup> і які тривають вічно, не маючи можливості їх повністю завершити.</p>

            <h3 id="focus-palettes">4.1. Палітри фокусів</h3>
            <p>Палітра безперервних фокусів неймовірно схожа на визначення національного дерева фокусів, але з меншою кількістю аргументів.</p>
            <ul>
                <li><code>id = my_focus_palette</code> визначає ID палітри фокусів. Обов'язково.</li>
                <li><code>country = { ... }</code> — це блок MTTH, який присвоює оцінки кожній країні для вибору палітри безперервних фокусів, точно так само, як це робиться з національними деревами фокусів.</li>
                <li><code>default = yes</code> призначає палітру фокусів як стандартну. Як і з національними деревами фокусів, лише одна палітра загалом повинна бути стандартною: не більше, не менше. За замовчуванням <code>false</code>.</li>
                <li><code>reset_on_civilwar = no</code> аналогічно національним фокусам, має невідомий ефект.</li>
                <li><code>position = { x = 100 y = 1230 }</code> призначає стандартну позицію палітри безперервних фокусів, вимірюючи в пікселях позицію верхнього лівого кута. Це буде використано, якщо національне дерево фокусів країни не вказує іншу позицію, яка не є <code>x = 0 y = 0</code>.</li>
                <li><code>focus = { ... }</code> — це самі безперервні фокуси.</li>
            </ul>
            <p>Приклад: <button class="spoiler-button" onclick="toggleSpoiler(this)">Показати/Сховати</button></p>
            <div class="spoiler-content" style="display:none;">
            <pre><code>continuous_focus_palette = {
    id = generic_continuous_focuses
    country = { factor = 1 } # Застосовується до всіх, якщо немає більш специфічного
    default = yes
    position = { x = 50 y = 1000 } # Стандартна позиція

    focus = { # Приклад безперервного фокуса
        id = army_continuous
        icon = GFX_goal_generic_army_training
        cost = 0 # Безперервні фокуси не мають вартості завершення
        available = { # Завжди доступний, якщо виконано 10 фокусів
            # Тут зазвичай перевірки не потрібні, якщо це загальний фокус
        }
        modifier = { army_experience_gain_factor = 0.05 }
        select_effect = { set_country_flag = continuous_army_focus_active }
        cancel_effect = { clr_country_flag = continuous_army_focus_active }
        ai_will_do = { factor = 1 } # ШІ може його обрати
    }
    # ... інші безперервні фокуси
}</code></pre>
            </div>

            <h3 id="focuses-continuous">4.2. Фокуси</h3>
            <p>Безперервні фокуси також досить схожі на національні фокуси у визначенні, але є суттєві відмінності.</p>
            <ul>
                <li><code>id = TAG_focus_name</code> — ID безперервного фокуса. Не повинно бути збігів у різних палітрах. Це також використовується як ключ локалізації для назви фокуса, а додавання <code>_desc</code> використовується для отримання опису фокуса.</li>
                <li><code>icon = GFX_focus_icon_name</code> — спрайт іконки, що використовується безперервним фокусом. Аналогічно національному фокусу, повинен бути як звичайний значок, так і блиск, щоб він завжди працював належним чином.</li>
                <li><code>available = { ... }</code> — блок тригерів, необхідний для виконання, щоб фокус був видимим, на відміну від національних фокусів, де це робить його можливим для вибору. Замість цього блок тригерів, що використовується для того, щоб фокус можна було обрати, — це <code>enable = { ... }</code>. <code>available_if_capitulated = yes</code> також зробить фокус можливим для вибору під час капітуляції. Якщо <code>false</code>, фокус все одно буде видимим, але його не можна буде обрати.</li>
                <li><code>modifier = { ... }</code> — блок модифікаторів, який деталізує список модифікаторів та їхні значення, що додаються при виборі фокуса. Однак існують інші способи застосування безперервних бонусів, крім модифікаторів, такі як бонуси до досліджень для конкретних категорій та бонуси до обладнання. Для них можна використовувати <code>idea = idea_name</code>, що додасть ідею до країни при виборі фокуса та видалить її при скасуванні фокуса. Це рекомендується робити з прихованими ідеями, оскільки це показує ефекти ідеї при наведенні на фокус.</li>
                <li><code>select_effect = { ... }</code> та <code>cancel_effect = { ... }</code> — ефекти, що виконуються при виборі та скасуванні цього фокуса відповідно. Оскільки фокус можна обрати та скасувати будь-коли безкоштовно, рекомендується зробити їх повністю протилежними один одному, щоб це не давало гравцеві жодної переваги.</li>
                <li><code>daily_cost = 0.4</code> — вартість у щоденному прирості політичної влади для взяття цього фокуса порівняно з відсутністю будь-якого обраного фокуса, може бути десятковим.</li>
                <li><code>ai_will_do = { ... }</code> — блок MTTH, що працює точно так само, як <code>ai_will_do</code> у національних фокусах. Крім того, <code>supports_ai_strategy = AI_focus</code> робить фокус можливим для вибору ШІ, якщо він дотримується вказаного фокуса. Без цього ШІ ніколи не обере цей безперервний фокус.</li>
            </ul>
            <p>Приклади: <button class="spoiler-button" onclick="toggleSpoiler(this)">Показати/Сховати</button></p>
            <div class="spoiler-content" style="display:none;">
            <pre><code>focus = {
    id = infrastructure_continuous
    icon = GFX_goal_generic_construct_infrastructure
    # Доступність зазвичай визначається палітрою
    modifier = {
        infrastructure_construction_speed = 0.10
    }
    daily_cost = 0.05 # Невеликі витрати
    ai_will_do = { factor = 0.5 } # Менш пріоритетний для ШІ
}
focus = {
    id = research_speed_continuous
    icon = GFX_goal_generic_research_slot
    modifier = {
        research_speed_factor = 0.02
    }
    daily_cost = 0.1
    ai_will_do = { factor = 1.2 } # Більш пріоритетний
    supports_ai_strategy = research_focus # Дозволяє ШІ обирати, якщо є така стратегія
}</code></pre>
            </div>

            <hr>
            <h2 id="ai-strategy-plans">5. Плани стратегії ШІ</h2>
            <p><strong>Основна стаття: <a href="https://hoi4.paradoxwikis.com/AI_modding#AI_Strategy_Plans" target="_blank" rel="noopener noreferrer">Модинг ШІ § Плани стратегії ШІ</a></strong></p>
            <p><em>Це вікі, що підтримується спільнотою. Якщо ви помітили помилку, будь ласка, допоможіть її виправити.</em></p>
            <p>Плани стратегії ШІ вказують ШІ, що пріоритезувати залежно від обставин: яких радників обирати, які технології досліджувати, які стратегії ШІ застосовувати, і, що найважливіше тут, які фокуси обирати. Це короткий огляд планів стратегії ШІ суто для пріоритезації національних фокусів, повна інформація знаходиться в статті про Модинг ШІ. Одночасно може бути увімкнено кілька планів стратегії ШІ.</p>
            <p>Плани стратегії ШІ визначаються у файлах <code>/Hearts of Iron IV/common/ai_strategy_plans/*.txt</code>. У цих файлах новий план стратегії створюється як новий блок, назва якого повинна бути такою ж, як внутрішній ID плану.</p>
            <p>У цьому плані <code>name = "Назва плану ШІ"</code> та <code>desc = "Опис плану ШІ"</code> визначають назву та опис плану стратегії. Це ніколи не призначено для показу гравцеві, тому локалізувати його на різні мови ніколи не потрібно. Замість цього це використовується в консольній команді <code>aiview</code>, яка надає розробнику інформацію про те, що ШІ хоче пріоритезувати.</p>
            <p><code>allowed = { ... }</code>, аналогічно рішенням або ідеям, є блоком тригерів, що перевіряється лише на початку гри. В основному використовується для того, щоб вказати, для якої країни та DLC обмежувати план стратегії.</p>
            <p><code>enable = { ... }</code> перевіряється щодня, якщо <code>allowed</code> виконано. Якщо <code>enable = { ... }</code> виконано, то план стратегії ШІ буде призначено ШІ незалежно від того, чи стане <code>enable = { ... }</code> хибним пізніше чи ні. Зазвичай тригер <code>has_game_rule</code> використовується для роботи з власними ігровими правилами, що визначають, який шлях обере ШІ. <code>is_historical_focus_on</code> зазвичай використовується зі стандартним ігровим правилом ШІ, а прапори країни можна використовувати для рандомізації, налаштувавши <code>on_startup</code> для встановлення випадкового за допомогою <code>random_list</code>.</p>
            <p><code>abort = { ... }</code> перевіряється щодня, щоб змусити ШІ припинити використання цього плану стратегії ШІ, якщо <code>enable = { ... }</code> виконано. Крім того, він повинен бути хибним, щоб план стратегії ШІ можна було обрати.</p>
            <p><code>ai_national_focuses = { TAG_focus_name_1 TAG_focus_name_2 }</code> — це список національних фокусів, розділених пробілами, у тому порядку, в якому ШІ повинен їх виконувати. У цьому прикладі ШІ спочатку спробує виконати <code>TAG_focus_name_1</code>, якщо це можливо. Якщо його вже виконано або <code>TAG_focus_name_1</code> неможливо виконати, то ШІ спробує виконати <code>TAG_focus_name_2</code>. Якщо обидва фокуси неможливо виконати через те, що їх завершено або вони недоступні, то він перейде до інших фокусів, враховуючи <code>ai_will_do = { ... }</code>. Дотримуючись порядку фокусів, він ігнорує значення <code>ai_will_do = { ... }</code>.</p>
            <p><code>focus_factors = { ... }</code> присвоює множник значенням <code>ai_will_do</code> вказаного фокуса. Запис у цьому блоці виглядає як <code>TAG_focus_name = 3</code>. У цьому випадку це змусить значення <code>ai_will_do</code> фокуса помножитися на 3, припускаючи вагу плану стратегії ШІ 1. Якщо фокус має значення <code>ai_will_do</code> 4 після застосування модифікаторів, воно стане 12, якщо ШІ дотримується цього плану стратегії, і буде розглядатися як таке. І, звичайно, коефіцієнт 0 змусить фокус ніколи не обиратися без вказівки в <code>ai_national_focuses</code>. Це може слугувати швидшим у написанні або більш рандомізованим способом змусити ШІ дотримуватися політичного шляху, роблячи фокуси, які він ніколи не повинен обирати, мати значення 0.</p>
            <p><code>weight = { ... }</code> — це блок MTTH, що присвоює загальну вагу плану. Визначений так само, як <code>ai_will_do</code> національного фокуса, він множить кожен коефіцієнт у плані стратегії ШІ на вагу перед їх застосуванням. Вага 1.25 перетворить коефіцієнт фокуса 4 на 5 перед його застосуванням, наприклад. Це можна використовувати, щоб змусити ШІ дотримуватися плану стратегії суворіше в одних випадках і менш суворо в інших.</p>

            <h3 id="example-ai-plan">5.1. Приклад</h3>
            <p>Текст у цьому розділі за замовчуванням згорнуто. <button class="spoiler-button" onclick="toggleSpoiler(this)">Показати/Сховати</button></p>
            <div class="spoiler-content" style="display:none;">
            <pre><code>GER_rhineland_first_plan = {
    name = "Рейнланд Спочатку (Історичний)"
    desc = "ШІ Німеччини спробує спочатку взяти Рейнланд, потім інші фокуси."

    allowed = { original_tag = GER } # Тільки для Німеччини

    enable = { is_historical_focus_on = yes } # Лише якщо увімкнено історичний фокус

    abort = { # Скасувати, якщо Німеччина у війні або вже взяла Рейнланд
        OR = {
            has_war = yes
            has_completed_focus = GER_rhineland
        }
    }

    ai_national_focuses = { 
        GER_rhineland # Перший пріоритет
        GER_autarky 
        GER_army_innovation 
        # ... інші фокуси в бажаному порядку
    }

    focus_factors = { # Якщо не вказано в ai_national_focuses, ШІ все одно може їх взяти
        GER_oppose_hitler = 0 # Ніколи не брати цей шлях, якщо дотримується цього плану
        GER_demand_sudentenland = 1.5 # Трохи більший пріоритет
    }

    weight = { base = 100 } # Дуже висока вага, щоб ШІ точно дотримувався цього плану
}</code></pre>
            </div>

            <hr>
            <h2 id="notes-focus">6. Примітки</h2>
            <p><sup>[a]</sup> Динамічні країни при створенні знову пройдуть перевірку, що призначає дерево фокусів. Крім того, перезавантаження фокусів шляхом збереження поверх файлу дерева фокусів, коли увімкнено режим налагодження через налаштування запуску, також оновить цю перевірку.</p>
            <p><sup>[b]</sup> Стандартна позиція визначається у визначенні палітри у файлі <code>/Hearts of Iron IV/common/continuous_focus/*.txt</code>.</p>
            <p><sup>[c]</sup> Точний розмір однієї одиниці координат x та y використовує <code>focus_spacing positionType</code> у <code>/Hearts of Iron IV/interface/nationalfocusview.gui</code>.</p>
            <p><sup>[d]</sup> Якщо <code>mark_focus_tree_layout_dirty</code> розміщено в нагороді за фокус, він не буде позначено як завершений для тригера <code>has_completed_focus</code> на момент його виконання. Цього можна уникнути, використовуючи приховану подію, запущену негайно, яка має ефект оновлення перевірки всередині свого <code>immediate</code>. Альтернативно, ефект <code>load_focus_tree</code>, налаштований на збереження завершених фокусів, можна використовувати для позначення фокуса як завершеного перед оновленням.</p>
            <p><sup>[e]</sup> У шляхах до папок зворотна коса риска (<code>\</code>) може призвести до того, що гра не зможе прочитати папку, оскільки очікується, що вона використовуватиметься як керуючий символ. Замість цього бажано використовувати прямі косі риски, як у <code>texturefile = gfx/interface/goals/my_file.dds</code>.</p>

            <hr>
            <h2 id="references-focus">7. Посилання</h2>
            <ol>
                <li><code>NDefines.NAI.FOCUS_TREE_CONTINUE_FACTOR = 1.5</code> в Defines.</li>
                <li><code>NDefines.NFocus.FOCUS_POINT_DAYS = 7</code> в Defines.</li>
                <li><code>NDefines.NFocus.FOCUS_PROGRESS_PEACE = 1</code> та <code>NDefines.NFocus.FOCUS_PROGRESS_WAR = 1</code> в Defines.</li>
                <li><a href="https://forum.paradoxplaza.com/forum/developer-diary/hearts-of-iron-iv-development-diary-1st-of-may-2023.1584260/" target="_blank" rel="noopener noreferrer">Щоденник розробників | Модинг!</a>, щоденник розробників Paradox за 1.13.</li>
                <li><code>NDefines.NCountry.MIN_FOCUSES_FOR_CONTINUOUS = 10</code> в Defines.</li>
            </ol>
            <p>Зауважте, що при модифікації defines слід використовувати файл перевизначення define, а не копіювати весь файл, оскільки навіть інакше "незначні" оновлення можуть додавати нові defines, спричиняючи потенційні збої.</p>

        </div> <!-- кінець #main-content -->
        
        <hr> 

        <!-- Фокусоване навігаційне меню (таке ж, як на головній сторінці) -->
        <nav id="focused-navigation-menu" class="focused-navigation">
            <h2>Основні розділи в роботі</h2>
            <p class="focused-nav-description">Швидкий доступ до сторінок, що зараз створюються та перекладаються.</p>
            <div class="focused-nav-links">
                <a href="decisions" class="nav-card"> 
                    <span class="nav-card-title">Decisions</span>
                    <span class="nav-card-description">(Рішення)</span>
                </a>
                <a href="events" class="nav-card"> 
                    <span class="nav-card-title">Events</span>
                    <span class="nav-card-description">(Події)</span>
                </a>
                <a href="ideas" class="nav-card"> 
                    <span class="nav-card-title">Ideas</span>
                    <span class="nav-card-description">(Ідеї)</span>
                </a>
                <a href="national_focuses" class="nav-card current-page-link"> 
                    <span class="nav-card-title">National focuses</span>
                    <span class="nav-card-description">(Національні фокуси)</span>
                </a>
            </div>
        </nav>
    </div> <!-- кінець .container -->

    <footer>
        <p>Переклад сторінки National focus modding - Hearts of Iron 4 Wiki. Оригінал: <a href="https://hoi4.paradoxwikis.com/National_focus_modding" target="_blank" rel="noopener noreferrer">hoi4.paradoxwikis.com/National_focus_modding</a></p>
        <p>Дизайн та переклад (за допомогою ШІ) адаптовано для особистого використання.</p>
    </footer>
</div> <!-- кінець .page-wrapper -->

    <script>
        const themeSwitcher = document.getElementById('theme-switcher');
        const body = document.body;
        const defaultBaseClass = 'theme-dark-base'; 

        function applyTheme(themeName) {
            body.classList.remove('theme-light', 'theme-aistudio-dark', 'theme-nord-dark', 'theme-dracula', 'theme-one-dark-pro', defaultBaseClass);

            if (themeName === 'theme-light') {
                body.classList.add('theme-light');
            } else {
                body.classList.add(defaultBaseClass); 
                body.classList.add(themeName);       
            }
            if (themeSwitcher) {
                 themeSwitcher.value = themeName;
            }
            localStorage.setItem('theme', themeName); 
        }
        
        const savedTheme = localStorage.getItem('theme') || 'theme-light';
        applyTheme(savedTheme);

        if (themeSwitcher) {
            themeSwitcher.addEventListener('change', function() {
                applyTheme(this.value);
            });
        }
        
        function switchLanguage(lang) {
            if (lang === 'uk') {
                alert('Ви вже на українській версії.');
            } else if (lang === 'ru') {
                window.location.href = 'russian';
            }
        }

        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                try {
                    const targetElement = document.querySelector(targetId);
                    if (targetElement) {
                        const topBarHeight = document.querySelector('.top-bar')?.offsetHeight || 0;
                        const elementPosition = targetElement.getBoundingClientRect().top;
                        const offsetPosition = elementPosition + window.pageYOffset - topBarHeight - 15; 

                        window.scrollTo({
                            top: offsetPosition,
                            behavior: 'smooth'
                        });

                         if(history.pushState && targetId !== "#") { 
                            history.pushState(null, null, targetId);
                        } else if (targetId !== "#") {
                            location.hash = targetId;
                        }
                    } else {
                        console.warn("Елемент для прокрутки не знайдено:", targetId);
                    }
                } catch (error) {
                     console.warn("Помилка при виборі елемента для прокрутки:", targetId, error);
                }
            });
        });
        
        var scrollTopButton = document.getElementById("scrollTopBtn");
        if (!scrollTopButton) { 
            scrollTopButton = document.createElement("button");
            scrollTopButton.innerHTML = "↑";
            scrollTopButton.id = "scrollTopBtn";
            scrollTopButton.title = "Нагору";
            scrollTopButton.onclick = function() {
                window.scrollTo({top: 0, behavior: 'smooth'});
            };
            document.body.appendChild(scrollTopButton);
        }

        window.onscroll = function() {
            if (scrollTopButton) { 
                if (document.body.scrollTop > 100 || document.documentElement.scrollTop > 100) {
                    scrollTopButton.style.display = "block";
                } else {
                    scrollTopButton.style.display = "none";
                }
            }
        };

        // Функція для перемикання видимості спойлерів
        function toggleSpoiler(button) {
            const content = button.nextElementSibling;
            if (content.style.display === "none" || content.style.display === "") {
                content.style.display = "block";
                button.textContent = "Сховати";
            } else {
                content.style.display = "none";
                button.textContent = "Показати";
            }
        }
    </script>
</body>
</html>